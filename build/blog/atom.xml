<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://docs.junhechen.com/blog</id>
    <title>Junhe Chen' Documentations Blog</title>
    <updated>2023-05-16T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://docs.junhechen.com/blog"/>
    <subtitle>Junhe Chen' Documentations Blog</subtitle>
    <icon>https://docs.junhechen.com/img/icon.jpeg</icon>
    <entry>
        <title type="html"><![CDATA[Leetcode 2130]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 2130</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 2130"/>
        <updated>2023-05-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This involves going to middle, reverse second half and then pair them up]]></summary>
        <content type="html"><![CDATA[<p>This involves going to middle, reverse second half and then pair them up
two pass apporach with extra memory would be using stack</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Definition for singly-linked list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * public class ListNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     int val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode(int val) { this.val = val; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int pairSum(ListNode head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode slow = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode fast = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get middle of the linked list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (fast != null &amp;&amp; fast.next != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fast = fast.next.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow = slow.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Reverse second half of the linked list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode nextNode, prev = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (slow != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nextNode = slow.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow.next = prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            prev = slow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow = nextNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode start = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int maximumSum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (prev != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maximumSum = Math.max(maximumSum, start.val + prev.val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            prev = prev.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            start = start.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return maximumSum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="weeklychallenge" term="weeklychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 24]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 24</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 24"/>
        <updated>2023-05-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Little busy, but this is just as much a problem as reverse linkedlist.]]></summary>
        <content type="html"><![CDATA[<p>Little busy, but this is just as much a problem as reverse linkedlist. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ListNode swapPairs(ListNode head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(head == null || head.next == null) return head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode last = head.next; // this would be the new head, because we have to reverse curr and next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head.next = swapPairs(head.next.next); // the head is now the curr sections last node and it suppose to connect to the rest of the list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        last.next = head; // set the new head to connect to the curr head which is tail of the curr section</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return last;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="weeklychallenge" term="weeklychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1721]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1721</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1721"/>
        <updated>2023-05-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[this is a two pointer question, it uses slow fast pointer technique to get pointer to the kth node from the end, then find the front node !!]]></summary>
        <content type="html"><![CDATA[<p>this is a two pointer question, it uses slow fast pointer technique to get pointer to the kth node from the end, then find the front node !!</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ListNode swapNodes(ListNode head, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // locate the end node </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode slow = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode fast = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int k1 = k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(fast != null &amp;&amp; k1 &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fast = fast.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            k1 --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(fast != null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow = slow.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fast = fast.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode p = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(p != null &amp;&amp; k &gt; 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            p = p.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            k --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // make the swap </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int temp = p.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.val = slow.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slow.val = temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="265-paint-house-ii">265. Paint House II<a href="#265-paint-house-ii" class="hash-link" aria-label="Direct link to 265. Paint House II" title="Direct link to 265. Paint House II">​</a></h3><p>This is a classic dp problem, but also little like advance graph apporach! Be sure to review this problem again tomorrow!</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minCostII(int[][] costs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(costs.length == 0) return 0; // nothing to paint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int k = costs[0].length; // the k color we are looking for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = costs.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] previousRow = costs[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int house = 1; house &lt; n; house++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we going to look at curr costs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int[] currRow = new int[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int color = 0; color &lt; k; color ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // locate the cheapest solution from last row, we want the cheapest cost so far</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int previousColor = 0; previousColor &lt; k; previousColor ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(color == previousColor){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // we can't print two adjusent color same</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    min = Math.min(min, previousRow[previousColor]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // if we would paint curr house curr color, then we add cost from min previous house and cost of curr house </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                currRow[color] += costs[house][color] += min;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we want to change previousRow = curr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            previousRow = currRow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // now we have the final row, find return the res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int cost : previousRow){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.min(res,cost);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="weeklychallenge" term="weeklychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1799]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1799</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1799"/>
        <updated>2023-05-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The dp part of the problem is not hard, but mask is difficult, and that is what we have to take a closer look to.]]></summary>
        <content type="html"><![CDATA[<p>The dp part of the problem is not hard, but mask is difficult, and that is what we have to take a closer look to.
I need to review this question tmr again.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxScore(int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new int[ 1 &lt;&lt; nums.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(memo,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(nums, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(int[] nums, int mask, int pairsPicked){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(2 * pairsPicked == nums.length) return 0; // we picked all number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[mask] != -1) return memo[mask];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int max = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; nums.length; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = i + 1; j &lt; nums.length; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If the numbers are same, or already picked, then we move to next number.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (((mask &gt;&gt; i) &amp; 1) == 1 || ((mask &gt;&gt; j) &amp; 1) == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Both numbers are marked as picked in this new mask.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int newMask = mask | (1 &lt;&lt; i) | (1 &lt;&lt; j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 // Calculate score of current pair of numbers, and the remaining array.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int currScore = (pairsPicked + 1) * gcd(nums[i], nums[j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int remainingScore = dp(nums, newMask, pairsPicked + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Store the maximum score.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                max = Math.max(max, currScore + remainingScore);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // We will use old mask in loop's next interation, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // means we discarded the picked number and backtracked.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[mask] = max;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int gcd(int a, int b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (b == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return gcd(b, a % b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="weeklychallenge" term="weeklychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2466]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 2466</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 2466"/>
        <updated>2023-05-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[this question took me to realize, but read the instruction clearly this should be a easy problem.]]></summary>
        <content type="html"><![CDATA[<p>this question took me to realize, but read the instruction clearly this should be a easy problem.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int MOD = 1_000_000_007;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int countGoodStrings(int low, int high, int zero, int one) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[high + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = low; i &lt;= high; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += dp(i,zero,one);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res %= MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(int l, int zero, int one){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(l == 0) return 1; // we made to zero then we have 1 good string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(l &lt; zero &amp;&amp; l &lt; one) return 0; //this case we are not allowed to append </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[l] != null) return memo[l]; // we have done this before </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solving the problem </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int appendZeros = dp(l - zero,zero,one);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int appendOnes = dp(l - one, zero, one);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[l] = (appendOnes + appendZeros) % MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2140]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 2140</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 2140"/>
        <updated>2023-05-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Question is very easy to solve with dp you only have 2 option and you cache the reapeated branch and it would be solved.]]></summary>
        <content type="html"><![CDATA[<p>Question is very easy to solve with dp you only have 2 option and you cache the reapeated branch and it would be solved.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long mostPoints(int[][] questions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new long[questions.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(memo,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(questions,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long dp(int[][] questions, int curr){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(curr &gt;= questions.length) return 0; // no more questions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[curr] != -1) return memo[curr];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // two case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long skip = dp(questions,curr + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long take = questions[curr][0] + dp(questions,curr + questions[curr][1] + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[curr] = Math.max(skip,take);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1035]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1035</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1035"/>
        <updated>2023-05-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.]]></summary>
        <content type="html"><![CDATA[<p>It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxUncrossedLines(int[] nums1, int[] nums2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // to be as fast as possible we would want nums1 to be smaller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(nums1.length &gt; nums2.length){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return maxUncrossedLines(nums2,nums1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums1.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = nums2.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new int[n][m];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int[] row : memo){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Arrays.fill(row,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(nums1,nums2,0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(int[] nums1, int[] nums2,int p1, int p2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we have reached the end of either number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p1 == nums1.length || p2 == nums2.length) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[p1][p2] != -1) return memo[p1][p2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(nums1[p1] == nums2[p2]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we can connect them </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = 1 + dp(nums1,nums2,p1 + 1, p2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we cant connect them, we have two option</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1. we can skip the nums1 and not try to connect it </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 2. we can find the match number and connect nums2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // note there is no going back </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int skip = dp(nums1,nums2,p1 + 1, p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int connect = dp(nums1,nums2,p1,p2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.max(skip,connect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[p1][p2] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 59]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 59</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 59"/>
        <updated>2023-05-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[very similar question , just inserting into the matrix instead of traversaling it.]]></summary>
        <content type="html"><![CDATA[<p>very similar question , just inserting into the matrix instead of traversaling it.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] generateMatrix(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] res = new int[n][n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // define the boundry </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int up = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int down = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int right = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curr = 1; // we starting inserting one </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(curr &lt;= n * n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we have more stuff to insert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // first we want to insert from left to right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = left; i &lt;= right; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res[up][i] = curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we want to insert downwards </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = up + 1; j &lt;= down; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res[j][right] = curr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now if we are not on the same row we would wanna go cross left </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(up != down){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int i = right - 1; i &gt;= left; i --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res[down][i] = curr++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now finally we want to go down to up </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(left != right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int j = down - 1; j &gt; up; j --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res[j][left] = curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // shrink the boundry </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            up ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            down --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 54]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 54</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 54"/>
        <updated>2023-05-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Working with matrix can be challenging, in this question, the main thing is attention to detail, making sure adding no duplicate items and shrink the boundry.]]></summary>
        <content type="html"><![CDATA[<p>Working with matrix can be challenging, in this question, the main thing is attention to detail, making sure adding no duplicate items and shrink the boundry.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = matrix.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = matrix[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int up = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int down = m - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int right = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(res.size() &lt; m * n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // there is more item to traverse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // first we add everthing from left to right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = left; i &lt;= right; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.add(matrix[up][i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we add from up to down </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = up + 1; j &lt;= down; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.add(matrix[j][right]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // going from right to left but we got to make sure up != down that way we not adding duplicate row</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(up != down){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int i = right - 1; i &gt;= left; i --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(matrix[down][i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // from bot to top</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(left != right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // note we dont want to add matrix[up][left] it is added from the left to right traversal!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int j = down - 1; j &gt; up; j --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(matrix[j][left]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we just have to shrink the boundry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            up ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            down --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1572]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1572</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1572"/>
        <updated>2023-05-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[working with matrix can be difficult lets start this easy question tho.]]></summary>
        <content type="html"><![CDATA[<p>working with matrix can be difficult lets start this easy question tho.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int diagonalSum(int[][] mat) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = mat.length, m = mat[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int row = 0, col_primary = 0, col_secondary = m - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(row &lt; n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += mat[row][col_primary];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += mat[row][col_secondary];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(col_primary == col_secondary){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res -= mat[row][col_primary];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            row ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            col_primary ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            col_secondary --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>weekly challenge, simply mimic the matrix multiplication prune out 0s </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] multiply(int[][] mat1, int[][] mat2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = mat1.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int k = mat1[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = mat2[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] res = new int[n][m];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int rowIndex = 0; rowIndex &lt; n; rowIndex ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int elementIndex = 0; elementIndex &lt; k; elementIndex++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(mat1[rowIndex][elementIndex] != 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // if just 0 we dont have to calculate it just gonna be 0 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for(int colIndex = 0; colIndex &lt; m; colIndex++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        res[rowIndex][colIndex] += mat1[rowIndex][elementIndex] * mat2[elementIndex][colIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1964]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1964</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1964"/>
        <updated>2023-05-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Difficult problem I will come back to this question later.]]></summary>
        <content type="html"><![CDATA[<p>Difficult problem I will come back to this question later. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Integer&gt; answer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Find the rightmost insertion position. We use a fixed-length array and a changeable right boundary </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // to represent an arraylist of dynamic size.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int bisectRight(int[] A, int target, int right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (right == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (left &lt; right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int mid = left + (right - left) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (A[mid] &lt;= target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left = mid + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                right = mid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = obstacles.length, lisLength = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // lis[i] records the lowest increasing sequence of length i + 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] answer = new int[n], lis = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; n; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int height = obstacles[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Find the rightmost insertion position idx.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int idx = bisectRight(lis, height, lisLength);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (idx == lisLength)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lisLength++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lis[idx] = height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            answer[i] = idx + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return answer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1498]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1498</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1498"/>
        <updated>2023-05-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Todays question is bit harder than previous sliding window, because of findint the apparch , note we only need the min and max to determine if subsequnce between would be valid or not.]]></summary>
        <content type="html"><![CDATA[<p>Todays question is bit harder than previous sliding window, because of findint the apparch , note we only need the min and max to determine if subsequnce between would be valid or not.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numSubseq(int[] nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // still two pointer problem </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int MOD = 1000000007;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // compute the value of 2 to the power of each value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] power = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        power[0] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 1; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            power[i] = (power[i - 1] * 2) % MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0, right = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(left &lt;= right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nums[left] + nums[right] &lt;= target){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // what this means is the min at left and max at right,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // there are 2 ^ right - left subsequence that have nums[left] as the min and nums[right] as max, all theses subsequence is meeting our requirement.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += power[right - left];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res %= MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // max is too big, we shrink the window.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                right --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1456]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1456</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1456"/>
        <updated>2023-05-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[It just like question ask you longest substring without repating character, it is a sliding winodw problem. you keep track of the winodw and curr max and update the res.]]></summary>
        <content type="html"><![CDATA[<p>It just like question ask you longest substring without repating character, it is a sliding winodw problem. you keep track of the winodw and curr max and update the res.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxVowels(String s, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // sliding window </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0, right = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(right &lt; s.length()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char c = s.charAt(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == 'a' || c == 'e' || c == 'i' || c =='o' || c == 'u'){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // vowel </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // shrink window</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while((right - left + 1) &gt; k){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // it is too big </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                char shrink = s.charAt(left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(shrink == 'a' || shrink == 'e' || shrink == 'i' || shrink =='o' || shrink == 'u'){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // vowel </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    curr --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if((right - left + 1) &lt;= k){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res = Math.max(res,curr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 649]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 649</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 649"/>
        <updated>2023-05-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Natively we just follow the algorithm, since banning the next senate gives up the best advantage, we do that.]]></summary>
        <content type="html"><![CDATA[<p>Natively we just follow the algorithm, since banning the next senate gives up the best advantage, we do that.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String predictPartyVictory(String senate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // baning the new opposite party be the best </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuilder senates = new StringBuilder(senate); // for easy deletion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Count of Each Type of Senator to check for Winner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int dCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; senates.length(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (senates.charAt(i) == 'R') {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int turn = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(rCount &gt; 0 &amp;&amp; dCount &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we have power still</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(senates.charAt(turn) == 'R'){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // we going to ban next D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean banning_from_before = ban(senates,'D',(turn + 1) % senates.length());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(banning_from_before){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    turn --; //there is one opponent banned before this index, next to go is just next in turn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean banning_from_before = ban(senates,'R',(turn + 1) % senates.length());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(banning_from_before){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    turn --; //there is one opponent banned before this index, next to go is just next in turn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            turn = (turn + 1) % senates.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(rCount == 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return "Dire";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return "Radiant";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean ban(StringBuilder sb, Character party, int start){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean flag = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = start; i &lt; start + sb.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int curr = i % sb.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(curr == 0) flag = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(sb.charAt(curr) == party){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sb.deleteCharAt(curr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return flag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A better solution for this is using some datasturcture to impvore our time complecity.
Which structure serves first in first out? that is right a queue</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String predictPartyVictory(String senate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we still know the running curr senate for each party</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rCount = 0, dCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Floating Ban Count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int dFloatingBan = 0, rFloatingBan = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Queue of senators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Queue&lt;Character&gt; q = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(char c : senate.toCharArray()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            q.add(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == 'R') rCount ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else dCount ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(rCount &gt; 0 &amp;&amp; dCount &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char curr = q.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(curr == 'D') {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(dFloatingBan &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // we are banning this guy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dFloatingBan --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rFloatingBan ++; // banning next R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    q.add('D'); // adds back</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // same thing for ther other party</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(rFloatingBan &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rFloatingBan --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dFloatingBan ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    q.add('R');</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rCount == 0 ? "Dire" : "Radiant";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2215]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 2215</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 2215"/>
        <updated>2023-05-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Three easy question in a row, next might be hard. there is not much to talk about for this question.]]></summary>
        <content type="html"><![CDATA[<p>Three easy question in a row, next might be hard. there is not much to talk about for this question.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; findDifference(int[] nums1, int[] nums2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; seen1 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; seen2 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int num : nums1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seen1.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; distinct2 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int num : nums2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seen2.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(!seen1.contains(num)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                distinct2.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; distinct1 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int num : nums1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(!seen2.contains(num)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                distinct1.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return List.of(new ArrayList&lt;&gt;(distinct1),new ArrayList&lt;&gt;(distinct2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1822]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1822</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1822"/>
        <updated>2023-05-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is very easy question basically you count how many negative number.]]></summary>
        <content type="html"><![CDATA[<p>This is very easy question basically you count how many negative number.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int arraySign(int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; nums.length; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nums[i] == 0) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nums[i] &lt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count % 2 == 0 ? 1 : -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1491]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1491</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1491"/>
        <updated>2023-04-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Since today's questions are too easy, we just put down the res for both weekly challange and daily challange.]]></summary>
        <content type="html"><![CDATA[<p>Since today's questions are too easy, we just put down the res for both weekly challange and daily challange.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1419">1419<a href="#1419" class="hash-link" aria-label="Direct link to 1419" title="Direct link to 1419">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double average(int[] salary) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int max = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int total = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int n : salary){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            min = Math.min(min,n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            max = Math.max(max,n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            total += n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (total - min - max) / (double)(salary.length - 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1065">1065<a href="#1065" class="hash-link" aria-label="Direct link to 1065" title="Direct link to 1065">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// the native apporach</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] indexPairs(String text, String[] words) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(words,(a,b) -&gt;{return a.length() - b.length();}); // insure the order.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; text.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(String word : words){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(text.substring(i).startsWith(word)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(new int[]{i,i + word.length() - 1});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] ans = new int[res.size()][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; res.size(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ans[i] = res.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Because trie can detect a shorter word along the way, this avoid the sorting which can take extra time. this is a better solution.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class TrieNode{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean word;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode[] children;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TrieNode(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            word = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            children = new TrieNode[26]; //26 character</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class MyTrie{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public MyTrie(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            root = new TrieNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void add(String word){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode curr = root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(char c : word.toCharArray()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(curr.children[c - 'a'] == null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    curr.children[c - 'a'] = new TrieNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr = curr.children[c - 'a'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            curr.word = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean serach(String word){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode curr = root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(char c : word.toCharArray()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(curr.children[c - 'a'] == null) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr = curr.children[c - 'a'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return curr.word;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] indexPairs(String text, String[] words) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyTrie trie = new MyTrie();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(String word : words){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trie.add(word);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; text.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode p = trie.root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = i; j &lt; text.length(); j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (p.children[text.charAt(j) - 'a'] == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p = p.children[text.charAt(j) - 'a'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (p.word) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(new int[] { i, j });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] ans = new int[res.size()][];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ans = res.toArray(ans);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1579]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1579</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1579"/>
        <updated>2023-04-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Still union find, it is easy to identify, but there is little twist, initially I thought of sorting the edges, so we can union type 3 first, but this takes n log n time because sorting is bound by that, if we traversal twice the edges, still we only take just n time, so it would actually beat the way I implemented at begining. other than this, this question uses two union find data structure but everthing should be just the same.]]></summary>
        <content type="html"><![CDATA[<p>Still union find, it is easy to identify, but there is little twist, initially I thought of sorting the edges, so we can union type 3 first, but this takes n log n time because sorting is bound by that, if we traversal twice the edges, still we only take just n time, so it would actually beat the way I implemented at begining. other than this, this question uses two union find data structure but everthing should be just the same. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxNumEdgesToRemove(int n, int[][] edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // still union find</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we can remove edge if when we trying to connect the nodes are already connected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UnionFind alice = new UnionFind(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UnionFind bob = new UnionFind(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do union for type 3 first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int[] edge : edges){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(edge[0] == 3){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int a = edge[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int b = edge[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += (alice.union(a,b) | bob.union(a,b));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int[] edge : edges){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int type = edge[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int a = edge[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int b = edge[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(type == 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += alice.union(a,b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else if(type == 2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += bob.union(a,b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(alice.isValid() &amp;&amp; bob.isValid()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return edges.length - res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class UnionFind {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public UnionFind(int n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent = new int[n + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size = new int[n + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = 0; i &lt;= n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size[i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.n = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int find(int a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(parent[a] == a) return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return parent[a] = find(parent[a]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int union(int a, int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int pa = find(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int pb = find(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(pa == pb) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(size[pa] &gt; size[pb]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // join b into a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent[pb] = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size[pa] += size[pb];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent[pa] = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size[pb] += size[pa];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            n --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean isValid(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return n == 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1697]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1697</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1697"/>
        <updated>2023-04-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Another same union find question , you can figure out it is a union find problem by the hint that determine a and b connected and a minimal spanning tree kind of a deal.]]></summary>
        <content type="html"><![CDATA[<p>Another same union find question , you can figure out it is a union find problem by the hint that determine a and b connected and a minimal spanning tree kind of a deal.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int queriesCount = queries.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean[] res = new boolean[queriesCount];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // init </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        parent = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Store original indices with all queries.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] queriesWithIndex = new int[queriesCount][4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; queriesCount; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][0] = queries[i][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][1] = queries[i][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][2] = queries[i][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][3] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(edgeList,(a,b) -&gt;{return a[2] - b[2];});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(queriesWithIndex,(a,b) -&gt;{return a[2] - b[2];});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int edgesIndex = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; queriesCount; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int p = queriesWithIndex[i][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int q = queriesWithIndex[i][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int limit = queriesWithIndex[i][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int originalIndex = queriesWithIndex[i][3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // because we have the edges sorted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // while our paths are smaller than limit, we want to attache all the edges thta is less than limit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if this made p q in a same union aka connected, we return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(edgesIndex &lt; edgeList.length &amp;&amp; edgeList[edgesIndex][2] &lt; limit){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int node1 = edgeList[edgesIndex][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int node2 = edgeList[edgesIndex][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                union(node1,node2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                edgesIndex += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res[originalIndex] = find(p) == find(q);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int find(int a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(parent[a] == a) return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return parent[a] = find(parent[a]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int union(int a, int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pa = find(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pb = find(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(pa == pb) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(size[pa] &gt; pb){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pb] = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pa] += size[pb];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pa] = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pb] += size[pa];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 839]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 839</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 839"/>
        <updated>2023-04-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This question is marked hard, but in realality this is not a difficult question. Simple union find problem, you find all the samilar strs and union them , starts with n groups after union all possible strs, what you have left is group standing.]]></summary>
        <content type="html"><![CDATA[<p>This question is marked hard, but in realality this is not a difficult question. Simple union find problem, you find all the samilar strs and union them , starts with n groups after union all possible strs, what you have left is group standing. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // union find </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numSimilarGroups(String[] strs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = strs.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        parent = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = i + 1; j &lt; n; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String a = strs[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String b = strs[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(similar(a,b)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    count -= union(i,j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int find(int a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(parent[a] == a) return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return parent[a] = find(parent[a]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int union(int a, int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pa = find(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pb = find(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(pa == pb) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(size[pa] &gt; size[pb]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // join b to a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pb] = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pa] += size[pb];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pa] = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pb] += size[pa];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean similar(String a, String b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int diff = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; a.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(a.charAt(i) != b.charAt(i)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                diff ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return diff == 2 || diff == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 319]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 319</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 319"/>
        <updated>2023-04-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is a harder question for me, write on paper and find the parttern.]]></summary>
        <content type="html"><![CDATA[<p>This is a harder question for me, write on paper and find the parttern. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int bulbSwitch(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 0 all bulbs are off</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 1 all bulbs with factor of 1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 2 all bulbs with factor 2 (2,4,6,8,10)...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 3 all bulbs with factor 3 (3,6,9).....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // so we are finding number from 1 to n are perfect square</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // essencially we are trying to find the sqrt of the n </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (int) Math.sqrt(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 258]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 258</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 258"/>
        <updated>2023-04-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Simple reccurssion, you have a base case where you have just 1 digit, simply return it, you have recussive case, you add all the digit and return addDigits adds all these digit recurssively]]></summary>
        <content type="html"><![CDATA[<p>Simple reccurssion, you have a base case where you have just 1 digit, simply return it, you have recussive case, you add all the digit and return addDigits adds all these digit recurssively</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int addDigits(int num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(num &lt; 10) return num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(num != 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += num % 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            num /= 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return addDigits(res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2336]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 2336</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 2336"/>
        <updated>2023-04-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Consider we have a full infinite set at first]]></summary>
        <content type="html"><![CDATA[<p>Consider we have a full infinite set at first
Use a running curr to keep track of smallest number and priority queue to keep track if we have scarlet numbers before running smallest</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SmallestInfiniteSet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int curr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SmallestInfiniteSet() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // set curr smallest to 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curr = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int popSmallest() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(!pq.isEmpty())return pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if we have nothing in pq, curr smallest is what we poll out, and sus next number would be curr + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return curr - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addBack(int num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(num &lt; curr &amp; !pq.contains(num)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // number is small and we dont have it in our pq </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // add back</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * SmallestInfiniteSet obj = new SmallestInfiniteSet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * int param_1 = obj.popSmallest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * obj.addBack(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1046]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1046</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1046"/>
        <updated>2023-04-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Very straightforward question, just mimc the instruction using priority queue.]]></summary>
        <content type="html"><![CDATA[<p>Very straightforward question, just mimc the instruction using priority queue.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int lastStoneWeight(int[] stones) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // very straight forward, we use priority queue to ensure we polling the largest 2 stones</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;{return b - a;});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int stone : stones){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(stone);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // while we have 2 or more stones</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(pq.size() &gt; 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int a = pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int b = pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(a != b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int remain = Math.abs(a - b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq.add(remain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // return nothing if we got no stone or last stone standing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pq.isEmpty() ? 0 : pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1416]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1416</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1416"/>
        <updated>2023-04-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[All the dp problem is kinda similar, this is marked at hard, but in reality it is backtrack question possible sub array partition with little modification.]]></summary>
        <content type="html"><![CDATA[<p>All the dp problem is kinda similar, this is marked at hard, but in reality it is backtrack question possible sub array partition with little modification. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int MOD = 1000000007;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numberOfArrays(String s, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new int[s.length() + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(memo,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(s,k,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(String s, int k, int curr){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(curr == s.length()) return 1; // we have no more possible number to play with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s.charAt(curr) == '0') return 0; // leading zero</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[curr] != -1) return memo[curr];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // start res with 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = curr; i &lt; s.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // try pairtition at every possible point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String num = s.substring(curr,i + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if num &gt; k then we know we cant have this number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Long.parseLong(num) &gt; k)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // add to res if we made to the end (+ 1) res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = (res + dp(s,k,i + 1)) % MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[curr] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 727]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 727</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 727"/>
        <updated>2023-04-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This question interesting because our dp is not finding the min of the length but it is finding the ending index of given starting point p1. This is a very new DP problem that I have first encountered.]]></summary>
        <content type="html"><![CDATA[<p>This question interesting because our dp is not finding the min of the length but it is finding the ending index of given starting point p1. This is a very new DP problem that I have first encountered. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int start = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String minWindow(String s1, String s2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[s1.length()][s2.length() + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp(s1,s2,0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return start == -1 ? "" : s1.substring(start,start + min);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(String s1, String s2, int p1, int p2){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we use dp method to find the ending index at given index of s1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p2 == s2.length()) return p1; // we have all the character from p2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p1 == s1.length()) return Integer.MAX_VALUE; // we are not able to match </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[p1][p2] != null) return memo[p1][p2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solve the case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // starts with skip the character</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = dp(s1,s2,p1 + 1, p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s1.charAt(p1) == s2.charAt(p2)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we have a match </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.min(res,dp(s1,s2,p1 + 1, p2 + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p2 == 0 &amp;&amp; res &lt; Integer.MAX_VALUE){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // this is a valid starting point </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // note since we called skip first, that means we are always replacing the substring as we moving forward </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // so res - p1 &lt;= min is important here to locate the correct starting point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(res - p1 &lt;= min){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                min = res - p1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                start = p1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[p1][p2] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="weeklychallenge" term="weeklychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 1312]]></title>
        <id>https://docs.junhechen.com/blog/Leetcode 1312</id>
        <link href="https://docs.junhechen.com/blog/Leetcode 1312"/>
        <updated>2023-04-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This week we are been doing DP problems and this is one of them, it is quite easy to implement, but little tricky to find the entry point.]]></summary>
        <content type="html"><![CDATA[<p>This week we are been doing DP problems and this is one of them, it is quite easy to implement, but little tricky to find the entry point.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minInsertions(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we can think this as in a different prespective </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // what is longest we have to insert to make this a palindrome?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // that is correct we can insert s in reverse to complish that, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if we take out the character we already have that means everthing else would then become palindrome </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[s.length()][s.length()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuilder sb = new StringBuilder(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s.length() - lcs(s,sb.reverse().toString(),0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int lcs(String s1, String s2, int p1, int p2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // case if we used one of the string up </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p1 == s1.length()) return 0;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p2 == s2.length()) return 0; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[p1][p2] != null) return memo[p1][p2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solve the case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s1.charAt(p1) == s2.charAt(p2)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if we have a match </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return memo[p1][p2] =  1 + lcs(s1,s2,p1 + 1,p2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[p1][p2] = Math.max(lcs(s1,s2,p1 + 1,p2),lcs(s1,s2,p1,p2 + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="leetcode" term="leetcode"/>
        <category label="dailychallenge" term="dailychallenge"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>https://docs.junhechen.com/blog/welcome</id>
        <link href="https://docs.junhechen.com/blog/welcome"/>
        <updated>2023-04-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[👋 Hi!]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-hi">👋 Hi!<a href="#-hi" class="hash-link" aria-label="Direct link to 👋 Hi!" title="Direct link to 👋 Hi!">​</a></h2><p>I'm Junhe Chen <a href="https://bio.junhechen.com" target="_blank" rel="noopener noreferrer">(JC)</a>, a full stack software engineer. Proven talent for aligning project objectives with established and emerging computer science paradigms to achieve maximum operational impacts with minimum resource expenditures. Growth-focused leader with expertise spanning technology solutions, project management, business operations optimization, application development, team leadership, and client relationship management. Exceptional student with keen interpersonal, communications, and application development expertise.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a></h2><p>This blog is mainly used to :</p><ul><li>take notes for my leetcode challanges.</li><li>update learning notes from other readings.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="social-card">Social Card<a href="#social-card" class="hash-link" aria-label="Direct link to Social Card" title="Direct link to Social Card">​</a></h2><p><img loading="lazy" alt="Social Card" src="/assets/images/social-card-b429455e73f3312f23e5b335b6d503ed.png" width="425" height="206" class="img_ev3q"></p><p><strong><em>If you found information here useful, feel free to review them.</em></strong></p>]]></content>
        <author>
            <name>Junhe Chen</name>
            <uri>https://bio.junhechen.com</uri>
        </author>
        <category label="helloworld" term="helloworld"/>
    </entry>
</feed>