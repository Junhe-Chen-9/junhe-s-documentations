<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Junhe Chen' Documentations Blog</title>
        <link>https://docs.junhechen.com/blog</link>
        <description>Junhe Chen' Documentations Blog</description>
        <lastBuildDate>Thu, 25 May 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Leetcode 1140]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1140</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1140</guid>
            <pubDate>Thu, 25 May 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[][][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int stoneGameII(int[] piles) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[2][piles.length + 1][piles.length + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return stoneGame(piles,0,1,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int stoneGame(int[] piles, int curr, int M, int alex){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(curr &gt;= piles.length) return 0; // no more stone </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[alex][curr][M] != null) return memo[alex][curr][M];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = alex == 1 ? 1000000 : -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int stones = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int x = 1; x &lt;= Math.min(2 * M, piles.length - curr); x ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stones += piles[curr + x - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(alex == 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res = Math.max(res,stones + stoneGame(piles,curr + x,Math.max(M,x),1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res = Math.min(res,stoneGame(piles,curr + x, Math.max(M,x),0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[alex][curr][M] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 2542]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 2542</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 2542</guid>
            <pubDate>Tue, 23 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[The apporach is simple, we want sum to be as big as possible, but more importantly our nums2(min) has to be bigger because it grows faster.]]></description>
            <content:encoded><![CDATA[<p>The apporach is simple, we want sum to be as big as possible, but more importantly our nums2(min) has to be bigger because it grows faster. </p><p>So we sort by nums2 at each index, we want to have our nums2 to be at max</p><p>we add all k item into the priority queue, and once we got the score, we want to make sure our score is actually good, so we want to keep going on nums2, while we polls the smallest from the nums1 and keep update items.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long maxScore(int[] nums1, int[] nums2, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we want nums2 be as big as possible </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums1.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] pairs = new int[n][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pairs[i] = new int[]{nums1[i],nums2[i]};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(pairs,(a,b) -&gt; b[1] - a[1]); // we want to sort the pair by biggest in nums2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(k,(a,b) -&gt; a - b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long topK = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; k; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            topK += pairs[i][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(pairs[i][0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // score </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long res = topK * pairs[k - 1][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // slide all possiblity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = k; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            topK += pairs[i][0] - pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(pairs[i][0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.max(res,topK * pairs[i][1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 703]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 703</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 703</guid>
            <pubDate>Mon, 22 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Simple question using pq]]></description>
            <content:encoded><![CDATA[<p>Simple question using pq</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class KthLargest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public KthLargest(int k, int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.k = k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int n : nums) pq.add(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(pq.size() &gt; k) pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int add(int val) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pq.add(val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(pq.size() &gt; k){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pq.peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Your KthLargest object will be instantiated and called as such:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * KthLargest obj = new KthLargest(k, nums);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * int param_1 = obj.add(val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 347]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 347</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 347</guid>
            <pubDate>Sun, 21 May 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[] topKFrequent(int[] nums, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // don't think quicksort is acutally good here </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] res = new int[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashMap&lt;Integer,Integer&gt; count = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int n : nums){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(count.containsKey(n)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count.put(n,count.get(n) + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count.put(n,1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b) -&gt; {return b[1] - a[1];});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int key : count.keySet()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(new int[]{key,count.get(key)});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; k; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res[i] = pq.poll()[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 399]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 399</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 399</guid>
            <pubDate>Fri, 19 May 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // to solve this question</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we first wanna to think this as a graph and using dfs find the path from a to b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // in order to do so ,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we must construct a weighted graph</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashMap&lt;String,HashMap&lt;String,Double&gt;&gt; graph = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we need to get equations to gain our two string node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we also need to have a index to keep track </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(List&lt;String&gt; e : equations){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String a = e.get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String b = e.get(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.putIfAbsent(a,new HashMap&lt;&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.putIfAbsent(b,new HashMap&lt;&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.get(a).put(b,values[index]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.get(b).put(a,1 / values[index]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.get(a).put(a,1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.get(b).put(b,1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we have sucessfully build our graph</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // lets look at our queiries</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        double [] ans = new double[queries.size()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(ans,-1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; queries.size(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;String&gt; q = queries.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String start = q.get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String end = q.get(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check if start and end in the graph at all</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(!graph.containsKey(start) || !graph.containsKey(end)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dfs(graph,start,end,new HashSet&lt;String&gt;(),1.0,ans,i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let's make our dfs method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void dfs (HashMap&lt;String,HashMap&lt;String,Double&gt;&gt; graph, String start, String end, Set&lt;String&gt; visited, double pre, double[] ans, int index){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        visited.add(start);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(graph.get(start).containsKey(end)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ans[index] = graph.get(start).get(end) * pre;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(String next : graph.get(start).keySet()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (visited.contains(next)) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dfs(graph,next,end,visited,graph.get(start).get(next) * pre ,ans,index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 785]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 785</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 785</guid>
            <pubDate>Thu, 18 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Simple graph coloring question.]]></description>
            <content:encoded><![CDATA[<p>Simple graph coloring question.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isBipartite(int[][] graph) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // graph color</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = graph.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] color = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(color, -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(color[i] == -1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(!isBipartite(graph,i,color)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean isBipartite(int[][] graph, int curr, int[] color){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        color[curr] = 1; // color curr node to 1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        q.add(curr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(!q.isEmpty()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = q.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int next : graph[c]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(color[next] == color[c]) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(color[next] == -1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // this is not colored yet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    color[next] = 1 - color[c];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    q.add(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1557]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1557</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1557</guid>
            <pubDate>Wed, 17 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This is a tropological sort kind of problem, we can't use union find because we would union things all together.]]></description>
            <content:encoded><![CDATA[<p>This is a tropological sort kind of problem, we can't use union find because we would union things all together.
Instead, we should just care about nodes that aren't reachable from other nodes.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;Integer&gt; findSmallestSetOfVertices(int n, List&lt;List&lt;Integer&gt;&gt; edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean[] pointed = new boolean[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(List&lt;Integer&gt; edge : edges){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pointed[edge.get(1)] = true; // this node can be reached from other nodes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // any nodes cant be reached from other nodes we just add into res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(!pointed[i]) res.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 2130]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 2130</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 2130</guid>
            <pubDate>Tue, 16 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This involves going to middle, reverse second half and then pair them up]]></description>
            <content:encoded><![CDATA[<p>This involves going to middle, reverse second half and then pair them up
two pass apporach with extra memory would be using stack</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Definition for singly-linked list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * public class ListNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     int val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode(int val) { this.val = val; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int pairSum(ListNode head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode slow = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode fast = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get middle of the linked list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (fast != null &amp;&amp; fast.next != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fast = fast.next.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow = slow.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Reverse second half of the linked list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode nextNode, prev = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (slow != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nextNode = slow.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow.next = prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            prev = slow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow = nextNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode start = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int maximumSum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (prev != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maximumSum = Math.max(maximumSum, start.val + prev.val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            prev = prev.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            start = start.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return maximumSum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 24]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 24</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 24</guid>
            <pubDate>Mon, 15 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Little busy, but this is just as much a problem as reverse linkedlist.]]></description>
            <content:encoded><![CDATA[<p>Little busy, but this is just as much a problem as reverse linkedlist. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ListNode swapPairs(ListNode head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(head == null || head.next == null) return head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode last = head.next; // this would be the new head, because we have to reverse curr and next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head.next = swapPairs(head.next.next); // the head is now the curr sections last node and it suppose to connect to the rest of the list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        last.next = head; // set the new head to connect to the curr head which is tail of the curr section</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return last;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1721]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1721</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1721</guid>
            <pubDate>Sun, 14 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[this is a two pointer question, it uses slow fast pointer technique to get pointer to the kth node from the end, then find the front node !!]]></description>
            <content:encoded><![CDATA[<p>this is a two pointer question, it uses slow fast pointer technique to get pointer to the kth node from the end, then find the front node !!</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ListNode swapNodes(ListNode head, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // locate the end node </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode slow = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode fast = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int k1 = k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(fast != null &amp;&amp; k1 &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fast = fast.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            k1 --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(fast != null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            slow = slow.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fast = fast.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode p = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(p != null &amp;&amp; k &gt; 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            p = p.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            k --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // make the swap </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int temp = p.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.val = slow.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slow.val = temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="265-paint-house-ii">265. Paint House II<a href="#265-paint-house-ii" class="hash-link" aria-label="Direct link to 265. Paint House II" title="Direct link to 265. Paint House II"></a></h3><p>This is a classic dp problem, but also little like advance graph apporach! Be sure to review this problem again tomorrow!</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minCostII(int[][] costs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(costs.length == 0) return 0; // nothing to paint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int k = costs[0].length; // the k color we are looking for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = costs.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] previousRow = costs[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int house = 1; house &lt; n; house++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we going to look at curr costs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int[] currRow = new int[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int color = 0; color &lt; k; color ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // locate the cheapest solution from last row, we want the cheapest cost so far</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int previousColor = 0; previousColor &lt; k; previousColor ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(color == previousColor){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // we can't print two adjusent color same</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    min = Math.min(min, previousRow[previousColor]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // if we would paint curr house curr color, then we add cost from min previous house and cost of curr house </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                currRow[color] += costs[house][color] += min;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we want to change previousRow = curr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            previousRow = currRow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // now we have the final row, find return the res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int cost : previousRow){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.min(res,cost);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1799]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1799</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1799</guid>
            <pubDate>Sat, 13 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[The dp part of the problem is not hard, but mask is difficult, and that is what we have to take a closer look to.]]></description>
            <content:encoded><![CDATA[<p>The dp part of the problem is not hard, but mask is difficult, and that is what we have to take a closer look to.
I need to review this question tmr again.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxScore(int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new int[ 1 &lt;&lt; nums.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(memo,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(nums, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(int[] nums, int mask, int pairsPicked){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(2 * pairsPicked == nums.length) return 0; // we picked all number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[mask] != -1) return memo[mask];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int max = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; nums.length; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = i + 1; j &lt; nums.length; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If the numbers are same, or already picked, then we move to next number.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (((mask &gt;&gt; i) &amp; 1) == 1 || ((mask &gt;&gt; j) &amp; 1) == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Both numbers are marked as picked in this new mask.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int newMask = mask | (1 &lt;&lt; i) | (1 &lt;&lt; j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 // Calculate score of current pair of numbers, and the remaining array.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int currScore = (pairsPicked + 1) * gcd(nums[i], nums[j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int remainingScore = dp(nums, newMask, pairsPicked + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Store the maximum score.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                max = Math.max(max, currScore + remainingScore);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // We will use old mask in loop's next interation, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // means we discarded the picked number and backtracked.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[mask] = max;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int gcd(int a, int b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (b == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return gcd(b, a % b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 2466]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 2466</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 2466</guid>
            <pubDate>Fri, 12 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[this question took me to realize, but read the instruction clearly this should be a easy problem.]]></description>
            <content:encoded><![CDATA[<p>this question took me to realize, but read the instruction clearly this should be a easy problem.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int MOD = 1_000_000_007;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int countGoodStrings(int low, int high, int zero, int one) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[high + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = low; i &lt;= high; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += dp(i,zero,one);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res %= MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(int l, int zero, int one){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(l == 0) return 1; // we made to zero then we have 1 good string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(l &lt; zero &amp;&amp; l &lt; one) return 0; //this case we are not allowed to append </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[l] != null) return memo[l]; // we have done this before </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solving the problem </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int appendZeros = dp(l - zero,zero,one);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int appendOnes = dp(l - one, zero, one);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[l] = (appendOnes + appendZeros) % MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 2140]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 2140</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 2140</guid>
            <pubDate>Thu, 11 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Question is very easy to solve with dp you only have 2 option and you cache the reapeated branch and it would be solved.]]></description>
            <content:encoded><![CDATA[<p>Question is very easy to solve with dp you only have 2 option and you cache the reapeated branch and it would be solved.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long mostPoints(int[][] questions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new long[questions.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(memo,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(questions,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long dp(int[][] questions, int curr){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(curr &gt;= questions.length) return 0; // no more questions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[curr] != -1) return memo[curr];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // two case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long skip = dp(questions,curr + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long take = questions[curr][0] + dp(questions,curr + questions[curr][1] + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[curr] = Math.max(skip,take);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1035]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1035</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1035</guid>
            <pubDate>Wed, 10 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.]]></description>
            <content:encoded><![CDATA[<p>It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxUncrossedLines(int[] nums1, int[] nums2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // to be as fast as possible we would want nums1 to be smaller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(nums1.length &gt; nums2.length){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return maxUncrossedLines(nums2,nums1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums1.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = nums2.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new int[n][m];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int[] row : memo){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Arrays.fill(row,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(nums1,nums2,0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(int[] nums1, int[] nums2,int p1, int p2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we have reached the end of either number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p1 == nums1.length || p2 == nums2.length) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[p1][p2] != -1) return memo[p1][p2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(nums1[p1] == nums2[p2]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we can connect them </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = 1 + dp(nums1,nums2,p1 + 1, p2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we cant connect them, we have two option</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1. we can skip the nums1 and not try to connect it </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 2. we can find the match number and connect nums2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // note there is no going back </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int skip = dp(nums1,nums2,p1 + 1, p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int connect = dp(nums1,nums2,p1,p2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.max(skip,connect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[p1][p2] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 59]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 59</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 59</guid>
            <pubDate>Tue, 09 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[very similar question , just inserting into the matrix instead of traversaling it.]]></description>
            <content:encoded><![CDATA[<p>very similar question , just inserting into the matrix instead of traversaling it.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] generateMatrix(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] res = new int[n][n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // define the boundry </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int up = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int down = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int right = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curr = 1; // we starting inserting one </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(curr &lt;= n * n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we have more stuff to insert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // first we want to insert from left to right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = left; i &lt;= right; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res[up][i] = curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we want to insert downwards </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = up + 1; j &lt;= down; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res[j][right] = curr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now if we are not on the same row we would wanna go cross left </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(up != down){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int i = right - 1; i &gt;= left; i --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res[down][i] = curr++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now finally we want to go down to up </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(left != right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int j = down - 1; j &gt; up; j --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res[j][left] = curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // shrink the boundry </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            up ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            down --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 54]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 54</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 54</guid>
            <pubDate>Mon, 08 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Working with matrix can be challenging, in this question, the main thing is attention to detail, making sure adding no duplicate items and shrink the boundry.]]></description>
            <content:encoded><![CDATA[<p>Working with matrix can be challenging, in this question, the main thing is attention to detail, making sure adding no duplicate items and shrink the boundry.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = matrix.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = matrix[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int up = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int down = m - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int right = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(res.size() &lt; m * n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // there is more item to traverse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // first we add everthing from left to right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = left; i &lt;= right; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.add(matrix[up][i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we add from up to down </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = up + 1; j &lt;= down; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.add(matrix[j][right]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // going from right to left but we got to make sure up != down that way we not adding duplicate row</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(up != down){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int i = right - 1; i &gt;= left; i --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(matrix[down][i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // from bot to top</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(left != right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // note we dont want to add matrix[up][left] it is added from the left to right traversal!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int j = down - 1; j &gt; up; j --){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(matrix[j][left]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // now we just have to shrink the boundry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            up ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            down --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1572]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1572</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1572</guid>
            <pubDate>Sun, 07 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[working with matrix can be difficult lets start this easy question tho.]]></description>
            <content:encoded><![CDATA[<p>working with matrix can be difficult lets start this easy question tho.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int diagonalSum(int[][] mat) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = mat.length, m = mat[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int row = 0, col_primary = 0, col_secondary = m - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(row &lt; n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += mat[row][col_primary];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += mat[row][col_secondary];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(col_primary == col_secondary){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res -= mat[row][col_primary];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            row ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            col_primary ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            col_secondary --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>weekly challenge, simply mimic the matrix multiplication prune out 0s </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] multiply(int[][] mat1, int[][] mat2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = mat1.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int k = mat1[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int m = mat2[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] res = new int[n][m];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int rowIndex = 0; rowIndex &lt; n; rowIndex ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int elementIndex = 0; elementIndex &lt; k; elementIndex++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(mat1[rowIndex][elementIndex] != 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // if just 0 we dont have to calculate it just gonna be 0 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for(int colIndex = 0; colIndex &lt; m; colIndex++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        res[rowIndex][colIndex] += mat1[rowIndex][elementIndex] * mat2[elementIndex][colIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1964]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1964</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1964</guid>
            <pubDate>Sat, 06 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Difficult problem I will come back to this question later.]]></description>
            <content:encoded><![CDATA[<p>Difficult problem I will come back to this question later. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Integer&gt; answer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Find the rightmost insertion position. We use a fixed-length array and a changeable right boundary </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // to represent an arraylist of dynamic size.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int bisectRight(int[] A, int target, int right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (right == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (left &lt; right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int mid = left + (right - left) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (A[mid] &lt;= target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left = mid + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                right = mid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = obstacles.length, lisLength = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // lis[i] records the lowest increasing sequence of length i + 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] answer = new int[n], lis = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; n; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int height = obstacles[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Find the rightmost insertion position idx.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int idx = bisectRight(lis, height, lisLength);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (idx == lisLength)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lisLength++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lis[idx] = height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            answer[i] = idx + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return answer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1498]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1498</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1498</guid>
            <pubDate>Fri, 05 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Todays question is bit harder than previous sliding window, because of findint the apparch , note we only need the min and max to determine if subsequnce between would be valid or not.]]></description>
            <content:encoded><![CDATA[<p>Todays question is bit harder than previous sliding window, because of findint the apparch , note we only need the min and max to determine if subsequnce between would be valid or not.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numSubseq(int[] nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // still two pointer problem </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int MOD = 1000000007;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // compute the value of 2 to the power of each value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] power = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        power[0] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 1; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            power[i] = (power[i - 1] * 2) % MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0, right = n - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(left &lt;= right){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nums[left] + nums[right] &lt;= target){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // what this means is the min at left and max at right,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // there are 2 ^ right - left subsequence that have nums[left] as the min and nums[right] as max, all theses subsequence is meeting our requirement.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += power[right - left];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res %= MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // max is too big, we shrink the window.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                right --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1456]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1456</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1456</guid>
            <pubDate>Thu, 04 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[It just like question ask you longest substring without repating character, it is a sliding winodw problem. you keep track of the winodw and curr max and update the res.]]></description>
            <content:encoded><![CDATA[<p>It just like question ask you longest substring without repating character, it is a sliding winodw problem. you keep track of the winodw and curr max and update the res.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxVowels(String s, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // sliding window </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = 0, right = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(right &lt; s.length()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char c = s.charAt(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == 'a' || c == 'e' || c == 'i' || c =='o' || c == 'u'){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // vowel </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // shrink window</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while((right - left + 1) &gt; k){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // it is too big </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                char shrink = s.charAt(left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(shrink == 'a' || shrink == 'e' || shrink == 'i' || shrink =='o' || shrink == 'u'){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // vowel </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    curr --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if((right - left + 1) &lt;= k){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res = Math.max(res,curr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            right ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 649]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 649</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 649</guid>
            <pubDate>Wed, 03 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Natively we just follow the algorithm, since banning the next senate gives up the best advantage, we do that.]]></description>
            <content:encoded><![CDATA[<p>Natively we just follow the algorithm, since banning the next senate gives up the best advantage, we do that.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String predictPartyVictory(String senate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // baning the new opposite party be the best </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuilder senates = new StringBuilder(senate); // for easy deletion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Count of Each Type of Senator to check for Winner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int dCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; senates.length(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (senates.charAt(i) == 'R') {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int turn = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(rCount &gt; 0 &amp;&amp; dCount &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we have power still</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(senates.charAt(turn) == 'R'){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // we going to ban next D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean banning_from_before = ban(senates,'D',(turn + 1) % senates.length());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(banning_from_before){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    turn --; //there is one opponent banned before this index, next to go is just next in turn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean banning_from_before = ban(senates,'R',(turn + 1) % senates.length());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(banning_from_before){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    turn --; //there is one opponent banned before this index, next to go is just next in turn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            turn = (turn + 1) % senates.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(rCount == 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return "Dire";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return "Radiant";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean ban(StringBuilder sb, Character party, int start){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean flag = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = start; i &lt; start + sb.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int curr = i % sb.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(curr == 0) flag = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(sb.charAt(curr) == party){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sb.deleteCharAt(curr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return flag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A better solution for this is using some datasturcture to impvore our time complecity.
Which structure serves first in first out? that is right a queue</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String predictPartyVictory(String senate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we still know the running curr senate for each party</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rCount = 0, dCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Floating Ban Count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int dFloatingBan = 0, rFloatingBan = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Queue of senators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Queue&lt;Character&gt; q = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(char c : senate.toCharArray()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            q.add(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == 'R') rCount ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else dCount ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(rCount &gt; 0 &amp;&amp; dCount &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char curr = q.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(curr == 'D') {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(dFloatingBan &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // we are banning this guy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dFloatingBan --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rFloatingBan ++; // banning next R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    q.add('D'); // adds back</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // same thing for ther other party</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(rFloatingBan &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rFloatingBan --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rCount --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dFloatingBan ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    q.add('R');</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rCount == 0 ? "Dire" : "Radiant";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 2215]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 2215</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 2215</guid>
            <pubDate>Tue, 02 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Three easy question in a row, next might be hard. there is not much to talk about for this question.]]></description>
            <content:encoded><![CDATA[<p>Three easy question in a row, next might be hard. there is not much to talk about for this question.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; findDifference(int[] nums1, int[] nums2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; seen1 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; seen2 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int num : nums1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seen1.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; distinct2 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int num : nums2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seen2.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(!seen1.contains(num)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                distinct2.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Integer&gt; distinct1 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int num : nums1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(!seen2.contains(num)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                distinct1.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return List.of(new ArrayList&lt;&gt;(distinct1),new ArrayList&lt;&gt;(distinct2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1822]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1822</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1822</guid>
            <pubDate>Mon, 01 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This is very easy question basically you count how many negative number.]]></description>
            <content:encoded><![CDATA[<p>This is very easy question basically you count how many negative number.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int arraySign(int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; nums.length; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nums[i] == 0) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nums[i] &lt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count % 2 == 0 ? 1 : -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1491]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1491</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1491</guid>
            <pubDate>Sun, 30 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Since today's questions are too easy, we just put down the res for both weekly challange and daily challange.]]></description>
            <content:encoded><![CDATA[<p>Since today's questions are too easy, we just put down the res for both weekly challange and daily challange.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1419">1419<a href="#1419" class="hash-link" aria-label="Direct link to 1419" title="Direct link to 1419"></a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double average(int[] salary) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int max = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int total = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int n : salary){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            min = Math.min(min,n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            max = Math.max(max,n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            total += n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (total - min - max) / (double)(salary.length - 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1065">1065<a href="#1065" class="hash-link" aria-label="Direct link to 1065" title="Direct link to 1065"></a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// the native apporach</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] indexPairs(String text, String[] words) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(words,(a,b) -&gt;{return a.length() - b.length();}); // insure the order.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; text.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(String word : words){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(text.substring(i).startsWith(word)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(new int[]{i,i + word.length() - 1});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] ans = new int[res.size()][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; res.size(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ans[i] = res.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Because trie can detect a shorter word along the way, this avoid the sorting which can take extra time. this is a better solution.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class TrieNode{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean word;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode[] children;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TrieNode(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            word = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            children = new TrieNode[26]; //26 character</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class MyTrie{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public MyTrie(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            root = new TrieNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void add(String word){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode curr = root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(char c : word.toCharArray()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(curr.children[c - 'a'] == null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    curr.children[c - 'a'] = new TrieNode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr = curr.children[c - 'a'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            curr.word = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean serach(String word){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode curr = root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(char c : word.toCharArray()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(curr.children[c - 'a'] == null) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curr = curr.children[c - 'a'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return curr.word;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[][] indexPairs(String text, String[] words) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyTrie trie = new MyTrie();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(String word : words){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trie.add(word);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; text.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode p = trie.root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = i; j &lt; text.length(); j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (p.children[text.charAt(j) - 'a'] == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p = p.children[text.charAt(j) - 'a'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (p.word) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    res.add(new int[] { i, j });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] ans = new int[res.size()][];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ans = res.toArray(ans);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ans;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1579]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1579</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1579</guid>
            <pubDate>Sat, 29 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Still union find, it is easy to identify, but there is little twist, initially I thought of sorting the edges, so we can union type 3 first, but this takes n log n time because sorting is bound by that, if we traversal twice the edges, still we only take just n time, so it would actually beat the way I implemented at begining. other than this, this question uses two union find data structure but everthing should be just the same.]]></description>
            <content:encoded><![CDATA[<p>Still union find, it is easy to identify, but there is little twist, initially I thought of sorting the edges, so we can union type 3 first, but this takes n log n time because sorting is bound by that, if we traversal twice the edges, still we only take just n time, so it would actually beat the way I implemented at begining. other than this, this question uses two union find data structure but everthing should be just the same. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxNumEdgesToRemove(int n, int[][] edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // still union find</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we can remove edge if when we trying to connect the nodes are already connected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UnionFind alice = new UnionFind(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UnionFind bob = new UnionFind(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do union for type 3 first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int[] edge : edges){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(edge[0] == 3){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int a = edge[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int b = edge[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += (alice.union(a,b) | bob.union(a,b));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int[] edge : edges){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int type = edge[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int a = edge[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int b = edge[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(type == 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += alice.union(a,b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else if(type == 2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res += bob.union(a,b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(alice.isValid() &amp;&amp; bob.isValid()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return edges.length - res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class UnionFind {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public UnionFind(int n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent = new int[n + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size = new int[n + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = 0; i &lt;= n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size[i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.n = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int find(int a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(parent[a] == a) return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return parent[a] = find(parent[a]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int union(int a, int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int pa = find(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int pb = find(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(pa == pb) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(size[pa] &gt; size[pb]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // join b into a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent[pb] = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size[pa] += size[pb];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent[pa] = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size[pb] += size[pa];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            n --;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean isValid(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return n == 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1697]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1697</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1697</guid>
            <pubDate>Fri, 28 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Another same union find question , you can figure out it is a union find problem by the hint that determine a and b connected and a minimal spanning tree kind of a deal.]]></description>
            <content:encoded><![CDATA[<p>Another same union find question , you can figure out it is a union find problem by the hint that determine a and b connected and a minimal spanning tree kind of a deal.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int queriesCount = queries.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean[] res = new boolean[queriesCount];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // init </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        parent = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Store original indices with all queries.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] queriesWithIndex = new int[queriesCount][4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; queriesCount; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][0] = queries[i][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][1] = queries[i][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][2] = queries[i][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queriesWithIndex[i][3] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(edgeList,(a,b) -&gt;{return a[2] - b[2];});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(queriesWithIndex,(a,b) -&gt;{return a[2] - b[2];});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int edgesIndex = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; queriesCount; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int p = queriesWithIndex[i][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int q = queriesWithIndex[i][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int limit = queriesWithIndex[i][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int originalIndex = queriesWithIndex[i][3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // because we have the edges sorted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // while our paths are smaller than limit, we want to attache all the edges thta is less than limit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if this made p q in a same union aka connected, we return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(edgesIndex &lt; edgeList.length &amp;&amp; edgeList[edgesIndex][2] &lt; limit){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int node1 = edgeList[edgesIndex][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int node2 = edgeList[edgesIndex][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                union(node1,node2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                edgesIndex += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res[originalIndex] = find(p) == find(q);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int find(int a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(parent[a] == a) return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return parent[a] = find(parent[a]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int union(int a, int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pa = find(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pb = find(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(pa == pb) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(size[pa] &gt; pb){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pb] = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pa] += size[pb];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pa] = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pb] += size[pa];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 839]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 839</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 839</guid>
            <pubDate>Thu, 27 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This question is marked hard, but in realality this is not a difficult question. Simple union find problem, you find all the samilar strs and union them , starts with n groups after union all possible strs, what you have left is group standing.]]></description>
            <content:encoded><![CDATA[<p>This question is marked hard, but in realality this is not a difficult question. Simple union find problem, you find all the samilar strs and union them , starts with n groups after union all possible strs, what you have left is group standing. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // union find </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numSimilarGroups(String[] strs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = strs.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        parent = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size = new int[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[i] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; n; i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int j = i + 1; j &lt; n; j ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String a = strs[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String b = strs[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(similar(a,b)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    count -= union(i,j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int find(int a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(parent[a] == a) return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return parent[a] = find(parent[a]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int union(int a, int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pa = find(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pb = find(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(pa == pb) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(size[pa] &gt; size[pb]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // join b to a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pb] = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pa] += size[pb];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent[pa] = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size[pb] += size[pa];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean similar(String a, String b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int diff = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; a.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(a.charAt(i) != b.charAt(i)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                diff ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return diff == 2 || diff == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 319]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 319</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 319</guid>
            <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This is a harder question for me, write on paper and find the parttern.]]></description>
            <content:encoded><![CDATA[<p>This is a harder question for me, write on paper and find the parttern. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int bulbSwitch(int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 0 all bulbs are off</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 1 all bulbs with factor of 1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 2 all bulbs with factor 2 (2,4,6,8,10)...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n == 3 all bulbs with factor 3 (3,6,9).....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // so we are finding number from 1 to n are perfect square</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // essencially we are trying to find the sqrt of the n </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (int) Math.sqrt(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 258]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 258</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 258</guid>
            <pubDate>Tue, 25 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Simple reccurssion, you have a base case where you have just 1 digit, simply return it, you have recussive case, you add all the digit and return addDigits adds all these digit recurssively]]></description>
            <content:encoded><![CDATA[<p>Simple reccurssion, you have a base case where you have just 1 digit, simply return it, you have recussive case, you add all the digit and return addDigits adds all these digit recurssively</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int addDigits(int num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(num &lt; 10) return num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(num != 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res += num % 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            num /= 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return addDigits(res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 2336]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 2336</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 2336</guid>
            <pubDate>Mon, 24 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Consider we have a full infinite set at first]]></description>
            <content:encoded><![CDATA[<p>Consider we have a full infinite set at first
Use a running curr to keep track of smallest number and priority queue to keep track if we have scarlet numbers before running smallest</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SmallestInfiniteSet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int curr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SmallestInfiniteSet() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // set curr smallest to 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curr = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int popSmallest() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(!pq.isEmpty())return pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if we have nothing in pq, curr smallest is what we poll out, and sus next number would be curr + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curr ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return curr - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addBack(int num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(num &lt; curr &amp; !pq.contains(num)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // number is small and we dont have it in our pq </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // add back</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * SmallestInfiniteSet obj = new SmallestInfiniteSet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * int param_1 = obj.popSmallest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * obj.addBack(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1046]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1046</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1046</guid>
            <pubDate>Sun, 23 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Very straightforward question, just mimc the instruction using priority queue.]]></description>
            <content:encoded><![CDATA[<p>Very straightforward question, just mimc the instruction using priority queue.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int lastStoneWeight(int[] stones) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // very straight forward, we use priority queue to ensure we polling the largest 2 stones</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;{return b - a;});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int stone : stones){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(stone);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // while we have 2 or more stones</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(pq.size() &gt; 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int a = pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int b = pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(a != b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int remain = Math.abs(a - b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq.add(remain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // return nothing if we got no stone or last stone standing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pq.isEmpty() ? 0 : pq.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1416]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1416</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1416</guid>
            <pubDate>Sat, 22 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[All the dp problem is kinda similar, this is marked at hard, but in reality it is backtrack question possible sub array partition with little modification.]]></description>
            <content:encoded><![CDATA[<p>All the dp problem is kinda similar, this is marked at hard, but in reality it is backtrack question possible sub array partition with little modification. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int MOD = 1000000007;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numberOfArrays(String s, int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new int[s.length() + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(memo,-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dp(s,k,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(String s, int k, int curr){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(curr == s.length()) return 1; // we have no more possible number to play with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s.charAt(curr) == '0') return 0; // leading zero</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[curr] != -1) return memo[curr];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // start res with 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = curr; i &lt; s.length(); i ++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // try pairtition at every possible point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String num = s.substring(curr,i + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if num &gt; k then we know we cant have this number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Long.parseLong(num) &gt; k)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // add to res if we made to the end (+ 1) res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = (res + dp(s,k,i + 1)) % MOD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[curr] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 727]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 727</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 727</guid>
            <pubDate>Fri, 21 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This question interesting because our dp is not finding the min of the length but it is finding the ending index of given starting point p1. This is a very new DP problem that I have first encountered.]]></description>
            <content:encoded><![CDATA[<p>This question interesting because our dp is not finding the min of the length but it is finding the ending index of given starting point p1. This is a very new DP problem that I have first encountered. </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int start = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String minWindow(String s1, String s2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[s1.length()][s2.length() + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp(s1,s2,0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return start == -1 ? "" : s1.substring(start,start + min);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int dp(String s1, String s2, int p1, int p2){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we use dp method to find the ending index at given index of s1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p2 == s2.length()) return p1; // we have all the character from p2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p1 == s1.length()) return Integer.MAX_VALUE; // we are not able to match </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[p1][p2] != null) return memo[p1][p2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solve the case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // starts with skip the character</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int res = dp(s1,s2,p1 + 1, p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s1.charAt(p1) == s2.charAt(p2)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // we have a match </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = Math.min(res,dp(s1,s2,p1 + 1, p2 + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p2 == 0 &amp;&amp; res &lt; Integer.MAX_VALUE){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // this is a valid starting point </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // note since we called skip first, that means we are always replacing the substring as we moving forward </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // so res - p1 &lt;= min is important here to locate the correct starting point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(res - p1 &lt;= min){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                min = res - p1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                start = p1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[p1][p2] = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>weeklychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Leetcode 1312]]></title>
            <link>https://docs.junhechen.com/blog/Leetcode 1312</link>
            <guid>https://docs.junhechen.com/blog/Leetcode 1312</guid>
            <pubDate>Fri, 21 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[This week we are been doing DP problems and this is one of them, it is quite easy to implement, but little tricky to find the entry point.]]></description>
            <content:encoded><![CDATA[<p>This week we are been doing DP problems and this is one of them, it is quite easy to implement, but little tricky to find the entry point.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Integer[][] memo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minInsertions(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // we can think this as in a different prespective </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // what is longest we have to insert to make this a palindrome?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // that is correct we can insert s in reverse to complish that, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if we take out the character we already have that means everthing else would then become palindrome </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memo = new Integer[s.length()][s.length()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuilder sb = new StringBuilder(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s.length() - lcs(s,sb.reverse().toString(),0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int lcs(String s1, String s2, int p1, int p2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // base case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // case if we used one of the string up </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p1 == s1.length()) return 0;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(p2 == s2.length()) return 0; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solved case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(memo[p1][p2] != null) return memo[p1][p2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // solve the case </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s1.charAt(p1) == s2.charAt(p2)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if we have a match </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return memo[p1][p2] =  1 + lcs(s1,s2,p1 + 1,p2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[p1][p2] = Math.max(lcs(s1,s2,p1 + 1,p2),lcs(s1,s2,p1,p2 + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>leetcode</category>
            <category>dailychallenge</category>
            <category>notes</category>
        </item>
        <item>
            <title><![CDATA[Welcome]]></title>
            <link>https://docs.junhechen.com/blog/welcome</link>
            <guid>https://docs.junhechen.com/blog/welcome</guid>
            <pubDate>Thu, 20 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[ Hi!]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-hi"> Hi!<a href="#-hi" class="hash-link" aria-label="Direct link to  Hi!" title="Direct link to  Hi!"></a></h2><p>I'm Junhe Chen <a href="https://bio.junhechen.com" target="_blank" rel="noopener noreferrer">(JC)</a>, a full stack software engineer. Proven talent for aligning project objectives with established and emerging computer science paradigms to achieve maximum operational impacts with minimum resource expenditures. Growth-focused leader with expertise spanning technology solutions, project management, business operations optimization, application development, team leadership, and client relationship management. Exceptional student with keen interpersonal, communications, and application development expertise.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction"></a></h2><p>This blog is mainly used to :</p><ul><li>take notes for my leetcode challanges.</li><li>update learning notes from other readings.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="social-card">Social Card<a href="#social-card" class="hash-link" aria-label="Direct link to Social Card" title="Direct link to Social Card"></a></h2><p><img loading="lazy" alt="Social Card" src="/assets/images/social-card-b429455e73f3312f23e5b335b6d503ed.png" width="425" height="206" class="img_ev3q"></p><p><strong><em>If you found information here useful, feel free to review them.</em></strong></p>]]></content:encoded>
            <category>helloworld</category>
        </item>
    </channel>
</rss>