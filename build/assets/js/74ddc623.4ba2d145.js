"use strict";(self.webpackChunkjunhe_s_documents=self.webpackChunkjunhe_s_documents||[]).push([[5519],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=r.createContext({}),l=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(i.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(t),d=o,g=m["".concat(i,".").concat(d)]||m[d]||p[d]||a;return t?r.createElement(g,c(c({ref:n},u),{},{components:t})):r.createElement(g,c({ref:n},u))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,c=new Array(a);c[0]=d;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s[m]="string"==typeof e?e:o,c[1]=s;for(var l=2;l<a;l++)c[l]=t[l];return r.createElement.apply(null,c)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6265:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=t(7462),o=(t(7294),t(3905));const a={slug:"Leetcode 1035",title:"Leetcode 1035",authors:["junhechen"],tags:["leetcode","dailychallenge","notes"]},c=void 0,s={permalink:"/blog/Leetcode 1035",editUrl:"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-10-Leet Code.md",source:"@site/blog/2023-05-10-Leet Code.md",title:"Leetcode 1035",description:"It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.",date:"2023-05-10T00:00:00.000Z",formattedDate:"May 10, 2023",tags:[{label:"leetcode",permalink:"/blog/tags/leetcode"},{label:"dailychallenge",permalink:"/blog/tags/dailychallenge"},{label:"notes",permalink:"/blog/tags/notes"}],readingTime:1.1,hasTruncateMarker:!1,authors:[{name:"Junhe Chen",title:"Software Developer",url:"https://bio.junhechen.com",imageURL:"https://bio.junhechen.com/assets/IMG_1960.jpg",key:"junhechen"}],frontMatter:{slug:"Leetcode 1035",title:"Leetcode 1035",authors:["junhechen"],tags:["leetcode","dailychallenge","notes"]},prevItem:{title:"Leetcode 2140",permalink:"/blog/Leetcode 2140"},nextItem:{title:"Leetcode 59",permalink:"/blog/Leetcode 59"}},i={authorsImageUrls:[void 0]},l=[],u={toc:l},m="wrapper";function p(e){let{components:n,...t}=e;return(0,o.kt)(m,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    int[][] memo;\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\n        // to be as fast as possible we would want nums1 to be smaller\n        if(nums1.length > nums2.length){\n            return maxUncrossedLines(nums2,nums1);\n        }\n        int n = nums1.length;\n        int m = nums2.length;\n        memo = new int[n][m];\n        for(int[] row : memo){\n            Arrays.fill(row,-1);\n        }\n        return dp(nums1,nums2,0,0);\n    }\n    private int dp(int[] nums1, int[] nums2,int p1, int p2){\n        // base case \n        // we have reached the end of either number\n        if(p1 == nums1.length || p2 == nums2.length) return 0;\n        \n        // solved case\n        if(memo[p1][p2] != -1) return memo[p1][p2];\n        \n        int res = 0;\n        \n        if(nums1[p1] == nums2[p2]){\n            // we can connect them \n            res = 1 + dp(nums1,nums2,p1 + 1, p2 + 1);\n        }else{\n            // we cant connect them, we have two option\n            // 1. we can skip the nums1 and not try to connect it \n            // 2. we can find the match number and connect nums2\n            // note there is no going back \n            int skip = dp(nums1,nums2,p1 + 1, p2);\n            int connect = dp(nums1,nums2,p1,p2 + 1);\n            res = Math.max(skip,connect);\n        }\n        return memo[p1][p2] = res;\n    }\n}\n")))}p.isMDXComponent=!0}}]);