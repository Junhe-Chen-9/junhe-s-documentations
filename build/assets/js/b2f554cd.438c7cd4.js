"use strict";(self.webpackChunkjunhe_s_documents=self.webpackChunkjunhe_s_documents||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"Leetcode 703","metadata":{"permalink":"/blog/Leetcode 703","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-22-Leet Code.md","source":"@site/blog/2023-05-22-Leet Code.md","title":"Leetcode 703","description":"Simple question using pq","date":"2023-05-22T00:00:00.000Z","formattedDate":"May 22, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.375,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 703","title":"Leetcode 703","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"nextItem":{"title":"Leetcode 347","permalink":"/blog/Leetcode 347"}},"content":"Simple question using pq\\n```java\\nclass KthLargest {\\n\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    int k;\\n    public KthLargest(int k, int[] nums) {\\n        this.k = k;\\n        for(int n : nums) pq.add(n);\\n        while(pq.size() > k) pq.poll();\\n    }\\n    \\n    public int add(int val) {\\n        pq.add(val);\\n        if(pq.size() > k){\\n            pq.poll();\\n        }\\n        return pq.peek();\\n    }\\n}\\n\\n/**\\n * Your KthLargest object will be instantiated and called as such:\\n * KthLargest obj = new KthLargest(k, nums);\\n * int param_1 = obj.add(val);\\n */\\n```"},{"id":"Leetcode 347","metadata":{"permalink":"/blog/Leetcode 347","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-21-Leet Code.md","source":"@site/blog/2023-05-21-Leet Code.md","title":"Leetcode 347","description":"","date":"2023-05-21T00:00:00.000Z","formattedDate":"May 21, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.38,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 347","title":"Leetcode 347","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 703","permalink":"/blog/Leetcode 703"},"nextItem":{"title":"Leetcode 399","permalink":"/blog/Leetcode 399"}},"content":"```java\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        // don\'t think quicksort is acutally good here \\n        int[] res = new int[k];\\n        HashMap<Integer,Integer> count = new HashMap<>();\\n        for(int n : nums){\\n            if(count.containsKey(n)){\\n                count.put(n,count.get(n) + 1);\\n            }else{\\n                count.put(n,1);\\n            }\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {return b[1] - a[1];});\\n        for(int key : count.keySet()){\\n            pq.add(new int[]{key,count.get(key)});\\n        }\\n        for(int i = 0; i < k; i ++){\\n            res[i] = pq.poll()[0];\\n        }\\n        return res;\\n    }\\n}\\n```"},{"id":"Leetcode 399","metadata":{"permalink":"/blog/Leetcode 399","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-19-Leet Code.md","source":"@site/blog/2023-05-19-Leet Code.md","title":"Leetcode 399","description":"","date":"2023-05-19T00:00:00.000Z","formattedDate":"May 19, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.105,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 399","title":"Leetcode 399","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 347","permalink":"/blog/Leetcode 347"},"nextItem":{"title":"Leetcode 785","permalink":"/blog/Leetcode 785"}},"content":"```java\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // to solve this question\\n        // we first wanna to think this as a graph and using dfs find the path from a to b\\n        // in order to do so ,\\n        // we must construct a weighted graph\\n        HashMap<String,HashMap<String,Double>> graph = new HashMap<>();\\n        \\n        // we need to get equations to gain our two string node\\n        // we also need to have a index to keep track \\n        int index = 0;\\n        for(List<String> e : equations){\\n            String a = e.get(0);\\n            String b = e.get(1);\\n            \\n            graph.putIfAbsent(a,new HashMap<>());\\n            graph.putIfAbsent(b,new HashMap<>());\\n            \\n            \\n            graph.get(a).put(b,values[index]);\\n            graph.get(b).put(a,1 / values[index]);\\n            index ++;\\n            \\n            graph.get(a).put(a,1.0);\\n            graph.get(b).put(b,1.0);\\n            \\n        }\\n        // we have sucessfully build our graph\\n        // lets look at our queiries\\n        double [] ans = new double[queries.size()];\\n        Arrays.fill(ans,-1.0);\\n        for(int i = 0; i < queries.size(); i ++){\\n            List<String> q = queries.get(i);\\n            String start = q.get(0);\\n            String end = q.get(1);\\n            \\n            // check if start and end in the graph at all\\n            if(!graph.containsKey(start) || !graph.containsKey(end)){\\n                continue;\\n            }else {\\n                dfs(graph,start,end,new HashSet<String>(),1.0,ans,i);\\n            \\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n    // let\'s make our dfs method\\n    private void dfs (HashMap<String,HashMap<String,Double>> graph, String start, String end, Set<String> visited, double pre, double[] ans, int index){\\n        visited.add(start);\\n        if(graph.get(start).containsKey(end)){\\n            ans[index] = graph.get(start).get(end) * pre;\\n        }\\n        \\n        for(String next : graph.get(start).keySet()){\\n            if (visited.contains(next)) continue;\\n            dfs(graph,next,end,visited,graph.get(start).get(next) * pre ,ans,index);\\n        }\\n    }\\n}\\n```"},{"id":"Leetcode 785","metadata":{"permalink":"/blog/Leetcode 785","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-18-Leet Code.md","source":"@site/blog/2023-05-18-Leet Code.md","title":"Leetcode 785","description":"Simple graph coloring question.","date":"2023-05-18T00:00:00.000Z","formattedDate":"May 18, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.54,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 785","title":"Leetcode 785","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 399","permalink":"/blog/Leetcode 399"},"nextItem":{"title":"Leetcode 1557","permalink":"/blog/Leetcode 1557"}},"content":"Simple graph coloring question.\\n\\n```java\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        // graph color\\n        int n = graph.length;\\n        int[] color = new int[n];\\n        Arrays.fill(color, -1);\\n\\n        for(int i = 0; i < n; i ++){\\n            if(color[i] == -1){\\n                if(!isBipartite(graph,i,color)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isBipartite(int[][] graph, int curr, int[] color){\\n        Queue<Integer> q = new LinkedList<>();\\n        color[curr] = 1; // color curr node to 1 \\n        q.add(curr);\\n        while(!q.isEmpty()){\\n            int c = q.poll();\\n            for(int next : graph[c]){\\n                if(color[next] == color[c]) return false;\\n                if(color[next] == -1){\\n                    // this is not colored yet \\n                    color[next] = 1 - color[c];\\n                    q.add(next);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```"},{"id":"Leetcode 1557","metadata":{"permalink":"/blog/Leetcode 1557","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-17-Leet Code.md","source":"@site/blog/2023-05-17-Leet Code.md","title":"Leetcode 1557","description":"This is a tropological sort kind of problem, we can\'t use union find because we would union things all together.","date":"2023-05-17T00:00:00.000Z","formattedDate":"May 17, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.51,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1557","title":"Leetcode 1557","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 785","permalink":"/blog/Leetcode 785"},"nextItem":{"title":"Leetcode 2130","permalink":"/blog/Leetcode 2130"}},"content":"This is a tropological sort kind of problem, we can\'t use union find because we would union things all together.\\nInstead, we should just care about nodes that aren\'t reachable from other nodes.\\n\\n```java\\nclass Solution {\\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\\n        boolean[] pointed = new boolean[n];\\n        for(List<Integer> edge : edges){\\n            pointed[edge.get(1)] = true; // this node can be reached from other nodes\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < n; i ++){\\n            // any nodes cant be reached from other nodes we just add into res\\n            if(!pointed[i]) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```"},{"id":"Leetcode 2130","metadata":{"permalink":"/blog/Leetcode 2130","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-16-Leet Code.md","source":"@site/blog/2023-05-16-Leet Code.md","title":"Leetcode 2130","description":"This involves going to middle, reverse second half and then pair them up","date":"2023-05-16T00:00:00.000Z","formattedDate":"May 16, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.845,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 2130","title":"Leetcode 2130","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 1557","permalink":"/blog/Leetcode 1557"},"nextItem":{"title":"Leetcode 24","permalink":"/blog/Leetcode 24"}},"content":"This involves going to middle, reverse second half and then pair them up \\ntwo pass apporach with extra memory would be using stack\\n\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        // Get middle of the linked list.\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        // Reverse second half of the linked list.\\n        ListNode nextNode, prev = null;\\n        while (slow != null) {\\n            nextNode = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n        ListNode start = head;\\n        int maximumSum = 0;\\n        while (prev != null) {\\n            maximumSum = Math.max(maximumSum, start.val + prev.val);\\n            prev = prev.next;\\n            start = start.next;\\n        }\\n\\n        return maximumSum;\\n    }\\n}\\n\\n```"},{"id":"Leetcode 24","metadata":{"permalink":"/blog/Leetcode 24","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-15-Leet Code.md","source":"@site/blog/2023-05-15-Leet Code.md","title":"Leetcode 24","description":"Little busy, but this is just as much a problem as reverse linkedlist.","date":"2023-05-15T00:00:00.000Z","formattedDate":"May 15, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.515,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 24","title":"Leetcode 24","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 2130","permalink":"/blog/Leetcode 2130"},"nextItem":{"title":"Leetcode 1721","permalink":"/blog/Leetcode 1721"}},"content":"Little busy, but this is just as much a problem as reverse linkedlist. \\n\\n```java\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        // base case \\n        if(head == null || head.next == null) return head;\\n        ListNode last = head.next; // this would be the new head, because we have to reverse curr and next\\n        head.next = swapPairs(head.next.next); // the head is now the curr sections last node and it suppose to connect to the rest of the list\\n        last.next = head; // set the new head to connect to the curr head which is tail of the curr section\\n        return last;\\n    }\\n}\\n```"},{"id":"Leetcode 1721","metadata":{"permalink":"/blog/Leetcode 1721","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-14-Leet Code.md","source":"@site/blog/2023-05-14-Leet Code.md","title":"Leetcode 1721","description":"this is a two pointer question, it uses slow fast pointer technique to get pointer to the kth node from the end, then find the front node !!","date":"2023-05-14T00:00:00.000Z","formattedDate":"May 14, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.625,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1721","title":"Leetcode 1721","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 24","permalink":"/blog/Leetcode 24"},"nextItem":{"title":"Leetcode 1799","permalink":"/blog/Leetcode 1799"}},"content":"this is a two pointer question, it uses slow fast pointer technique to get pointer to the kth node from the end, then find the front node !!\\n\\n```java\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        // locate the end node \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        int k1 = k;\\n        while(fast != null && k1 > 0){\\n            fast = fast.next;\\n            k1 --;\\n        }\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        ListNode p = head;\\n        while(p != null && k > 1){\\n            p = p.next;\\n            k --;\\n        }\\n        // make the swap \\n        int temp = p.val;\\n        p.val = slow.val;\\n        slow.val = temp;\\n        return head;\\n    }\\n}\\n```\\n\\n\\n### 265. Paint House II ###\\nThis is a classic dp problem, but also little like advance graph apporach! Be sure to review this problem again tomorrow!\\n```java\\nclass Solution {\\n    public int minCostII(int[][] costs) {\\n        if(costs.length == 0) return 0; // nothing to paint\\n        int k = costs[0].length; // the k color we are looking for\\n        int n = costs.length;\\n        int[] previousRow = costs[0];\\n\\n        for(int house = 1; house < n; house++){\\n            // we going to look at curr costs\\n            int[] currRow = new int[k];\\n            for(int color = 0; color < k; color ++){\\n                int min = Integer.MAX_VALUE;\\n                // locate the cheapest solution from last row, we want the cheapest cost so far\\n                for(int previousColor = 0; previousColor < k; previousColor ++){\\n                    if(color == previousColor){\\n                        // we can\'t print two adjusent color same\\n                        continue;\\n                    }\\n                    min = Math.min(min, previousRow[previousColor]);\\n                }\\n                // if we would paint curr house curr color, then we add cost from min previous house and cost of curr house \\n                currRow[color] += costs[house][color] += min;\\n            }\\n            // now we want to change previousRow = curr\\n            previousRow = currRow;\\n        }\\n        // now we have the final row, find return the res\\n        int res = Integer.MAX_VALUE;\\n        for(int cost : previousRow){\\n            res = Math.min(res,cost);\\n        }\\n        return res;\\n    }\\n}\\n```"},{"id":"Leetcode 1799","metadata":{"permalink":"/blog/Leetcode 1799","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-13-Leet Code.md","source":"@site/blog/2023-05-13-Leet Code.md","title":"Leetcode 1799","description":"The dp part of the problem is not hard, but mask is difficult, and that is what we have to take a closer look to.","date":"2023-05-13T00:00:00.000Z","formattedDate":"May 13, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.29,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1799","title":"Leetcode 1799","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 1721","permalink":"/blog/Leetcode 1721"},"nextItem":{"title":"Leetcode 2466","permalink":"/blog/Leetcode 2466"}},"content":"The dp part of the problem is not hard, but mask is difficult, and that is what we have to take a closer look to.\\nI need to review this question tmr again.\\n\\n\\n```java\\nclass Solution {\\n    int[] memo;\\n    public int maxScore(int[] nums) {\\n        memo = new int[ 1 << nums.length];\\n        Arrays.fill(memo,-1);\\n        return dp(nums, 0, 0);\\n    }\\n    private int dp(int[] nums, int mask, int pairsPicked){\\n        // base case \\n        if(2 * pairsPicked == nums.length) return 0; // we picked all number\\n        // solved case\\n        if(memo[mask] != -1) return memo[mask];\\n\\n        int max = 0;\\n        for(int i = 0; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                // If the numbers are same, or already picked, then we move to next number.\\n                if (((mask >> i) & 1) == 1 || ((mask >> j) & 1) == 1) {\\n                    continue;\\n                }\\n\\n                // Both numbers are marked as picked in this new mask.\\n                int newMask = mask | (1 << i) | (1 << j);\\n                 // Calculate score of current pair of numbers, and the remaining array.\\n                int currScore = (pairsPicked + 1) * gcd(nums[i], nums[j]);\\n                int remainingScore = dp(nums, newMask, pairsPicked + 1);\\n\\n                // Store the maximum score.\\n                max = Math.max(max, currScore + remainingScore);\\n                // We will use old mask in loop\'s next interation, \\n                // means we discarded the picked number and backtracked.\\n            }\\n        }\\n        return memo[mask] = max;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```"},{"id":"Leetcode 2466","metadata":{"permalink":"/blog/Leetcode 2466","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-12-Leet Code.md","source":"@site/blog/2023-05-12-Leet Code.md","title":"Leetcode 2466","description":"this question took me to realize, but read the instruction clearly this should be a easy problem.","date":"2023-05-12T00:00:00.000Z","formattedDate":"May 12, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.77,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 2466","title":"Leetcode 2466","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1799","permalink":"/blog/Leetcode 1799"},"nextItem":{"title":"Leetcode 2140","permalink":"/blog/Leetcode 2140"}},"content":"this question took me to realize, but read the instruction clearly this should be a easy problem.\\n\\n```java\\nclass Solution {\\n    Integer[] memo;\\n    int MOD = 1_000_000_007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        memo = new Integer[high + 1];\\n        int res = 0;\\n        for(int i = low; i <= high; i ++){\\n            res += dp(i,zero,one);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n    private int dp(int l, int zero, int one){\\n        // base case \\n        if(l == 0) return 1; // we made to zero then we have 1 good string\\n        if(l < zero && l < one) return 0; //this case we are not allowed to append \\n        // solved case \\n        if(memo[l] != null) return memo[l]; // we have done this before \\n        // solving the problem \\n        int appendZeros = dp(l - zero,zero,one);\\n        int appendOnes = dp(l - one, zero, one);\\n        return memo[l] = (appendOnes + appendZeros) % MOD;\\n    }\\n}\\n```"},{"id":"Leetcode 2140","metadata":{"permalink":"/blog/Leetcode 2140","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-11-Leet Code.md","source":"@site/blog/2023-05-11-Leet Code.md","title":"Leetcode 2140","description":"Question is very easy to solve with dp you only have 2 option and you cache the reapeated branch and it would be solved.","date":"2023-05-11T00:00:00.000Z","formattedDate":"May 11, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.46,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 2140","title":"Leetcode 2140","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 2466","permalink":"/blog/Leetcode 2466"},"nextItem":{"title":"Leetcode 1035","permalink":"/blog/Leetcode 1035"}},"content":"Question is very easy to solve with dp you only have 2 option and you cache the reapeated branch and it would be solved.\\n\\n\\n```java\\nclass Solution {\\n    long[] memo;\\n    public long mostPoints(int[][] questions) {\\n        memo = new long[questions.length];\\n        Arrays.fill(memo,-1);\\n        return dp(questions,0);\\n    }\\n    private long dp(int[][] questions, int curr){\\n        // base case \\n        if(curr >= questions.length) return 0; // no more questions\\n        if(memo[curr] != -1) return memo[curr];\\n        // two case \\n        long skip = dp(questions,curr + 1);\\n        long take = questions[curr][0] + dp(questions,curr + questions[curr][1] + 1);\\n        return memo[curr] = Math.max(skip,take);\\n    }\\n}\\n```"},{"id":"Leetcode 1035","metadata":{"permalink":"/blog/Leetcode 1035","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-10-Leet Code.md","source":"@site/blog/2023-05-10-Leet Code.md","title":"Leetcode 1035","description":"It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.","date":"2023-05-10T00:00:00.000Z","formattedDate":"May 10, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.1,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1035","title":"Leetcode 1035","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 2140","permalink":"/blog/Leetcode 2140"},"nextItem":{"title":"Leetcode 59","permalink":"/blog/Leetcode 59"}},"content":"It is a change of format for longest increase subsequence. You can only not cross by going forward only, and there is only two option, trying to connect curr number or give up on this number and go to next already.\\n\\n```java\\nclass Solution {\\n    int[][] memo;\\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\\n        // to be as fast as possible we would want nums1 to be smaller\\n        if(nums1.length > nums2.length){\\n            return maxUncrossedLines(nums2,nums1);\\n        }\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        memo = new int[n][m];\\n        for(int[] row : memo){\\n            Arrays.fill(row,-1);\\n        }\\n        return dp(nums1,nums2,0,0);\\n    }\\n    private int dp(int[] nums1, int[] nums2,int p1, int p2){\\n        // base case \\n        // we have reached the end of either number\\n        if(p1 == nums1.length || p2 == nums2.length) return 0;\\n        \\n        // solved case\\n        if(memo[p1][p2] != -1) return memo[p1][p2];\\n        \\n        int res = 0;\\n        \\n        if(nums1[p1] == nums2[p2]){\\n            // we can connect them \\n            res = 1 + dp(nums1,nums2,p1 + 1, p2 + 1);\\n        }else{\\n            // we cant connect them, we have two option\\n            // 1. we can skip the nums1 and not try to connect it \\n            // 2. we can find the match number and connect nums2\\n            // note there is no going back \\n            int skip = dp(nums1,nums2,p1 + 1, p2);\\n            int connect = dp(nums1,nums2,p1,p2 + 1);\\n            res = Math.max(skip,connect);\\n        }\\n        return memo[p1][p2] = res;\\n    }\\n}\\n```"},{"id":"Leetcode 59","metadata":{"permalink":"/blog/Leetcode 59","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-09-Leet Code.md","source":"@site/blog/2023-05-09-Leet Code.md","title":"Leetcode 59","description":"very similar question , just inserting into the matrix instead of traversaling it.","date":"2023-05-09T00:00:00.000Z","formattedDate":"May 9, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.015,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 59","title":"Leetcode 59","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1035","permalink":"/blog/Leetcode 1035"},"nextItem":{"title":"Leetcode 54","permalink":"/blog/Leetcode 54"}},"content":"very similar question , just inserting into the matrix instead of traversaling it.\\n\\n```java\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] res = new int[n][n];\\n        // define the boundry \\n        int up = 0;\\n        int down = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int curr = 1; // we starting inserting one \\n        while(curr <= n * n){\\n            // we have more stuff to insert\\n            // first we want to insert from left to right\\n            for(int i = left; i <= right; i ++){\\n                res[up][i] = curr ++;\\n            }\\n            // now we want to insert downwards \\n            for(int j = up + 1; j <= down; j ++){\\n                res[j][right] = curr;\\n                curr ++;\\n            }\\n            // now if we are not on the same row we would wanna go cross left \\n            if(up != down){\\n                for(int i = right - 1; i >= left; i --){\\n                    res[down][i] = curr++;\\n                }\\n            }\\n            // now finally we want to go down to up \\n            if(left != right){\\n                for(int j = down - 1; j > up; j --){\\n                    res[j][left] = curr ++;\\n                }\\n            }\\n            // shrink the boundry \\n            left ++;\\n            right --;\\n            up ++;\\n            down --;\\n        }\\n        return res;\\n    }\\n    \\n}\\n```"},{"id":"Leetcode 54","metadata":{"permalink":"/blog/Leetcode 54","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-08-Leet Code.md","source":"@site/blog/2023-05-08-Leet Code.md","title":"Leetcode 54","description":"Working with matrix can be challenging, in this question, the main thing is attention to detail, making sure adding no duplicate items and shrink the boundry.","date":"2023-05-08T00:00:00.000Z","formattedDate":"May 8, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.11,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 54","title":"Leetcode 54","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 59","permalink":"/blog/Leetcode 59"},"nextItem":{"title":"Leetcode 1572","permalink":"/blog/Leetcode 1572"}},"content":"Working with matrix can be challenging, in this question, the main thing is attention to detail, making sure adding no duplicate items and shrink the boundry.\\n\\n```java\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int up = 0;\\n        int down = m - 1;\\n        int left = 0;\\n        int right = n - 1;\\n\\n        while(res.size() < m * n){\\n            // there is more item to traverse\\n            // first we add everthing from left to right\\n            for(int i = left; i <= right; i ++){\\n                res.add(matrix[up][i]);\\n            }\\n            // now we add from up to down \\n            for(int j = up + 1; j <= down; j ++){\\n                res.add(matrix[j][right]);\\n            }\\n            // going from right to left but we got to make sure up != down that way we not adding duplicate row\\n            if(up != down){\\n                for(int i = right - 1; i >= left; i --){\\n                    res.add(matrix[down][i]);\\n                }\\n            }\\n            // from bot to top\\n            if(left != right){\\n                // note we dont want to add matrix[up][left] it is added from the left to right traversal!\\n                for(int j = down - 1; j > up; j --){\\n                    res.add(matrix[j][left]);\\n                }\\n            }\\n\\n            // now we just have to shrink the boundry\\n            left ++;\\n            right --;\\n            up ++;\\n            down --;\\n        }\\n        return res;\\n    }\\n}\\n```"},{"id":"Leetcode 1572","metadata":{"permalink":"/blog/Leetcode 1572","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-07-Leet Cod.md","source":"@site/blog/2023-05-07-Leet Cod.md","title":"Leetcode 1572","description":"working with matrix can be difficult lets start this easy question tho.","date":"2023-05-07T00:00:00.000Z","formattedDate":"May 7, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.83,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1572","title":"Leetcode 1572","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 54","permalink":"/blog/Leetcode 54"},"nextItem":{"title":"Leetcode 1964","permalink":"/blog/Leetcode 1964"}},"content":"working with matrix can be difficult lets start this easy question tho.\\n\\n```java\\nclass Solution {\\n    public int diagonalSum(int[][] mat) {\\n        int res = 0;\\n        int n = mat.length, m = mat[0].length;\\n        int row = 0, col_primary = 0, col_secondary = m - 1;\\n        while(row < n){\\n            res += mat[row][col_primary];\\n            res += mat[row][col_secondary];\\n            if(col_primary == col_secondary){\\n                res -= mat[row][col_primary];\\n            }\\n            row ++;\\n            col_primary ++;\\n            col_secondary --;\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```\\n\\n\\nweekly challenge, simply mimic the matrix multiplication prune out 0s \\n\\n```java\\nclass Solution {\\n    public int[][] multiply(int[][] mat1, int[][] mat2) {\\n        int n = mat1.length;\\n        int k = mat1[0].length;\\n        int m = mat2[0].length;\\n        int[][] res = new int[n][m];\\n\\n        for(int rowIndex = 0; rowIndex < n; rowIndex ++){\\n            for(int elementIndex = 0; elementIndex < k; elementIndex++){\\n                if(mat1[rowIndex][elementIndex] != 0){\\n                    // if just 0 we dont have to calculate it just gonna be 0 \\n                    for(int colIndex = 0; colIndex < m; colIndex++){\\n                        res[rowIndex][colIndex] += mat1[rowIndex][elementIndex] * mat2[elementIndex][colIndex];\\n                    } \\n                }\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```"},{"id":"Leetcode 1964","metadata":{"permalink":"/blog/Leetcode 1964","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-06-Leet Code.md","source":"@site/blog/2023-05-06-Leet Code.md","title":"Leetcode 1964","description":"Difficult problem I will come back to this question later.","date":"2023-05-06T00:00:00.000Z","formattedDate":"May 6, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.85,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1964","title":"Leetcode 1964","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1572","permalink":"/blog/Leetcode 1572"},"nextItem":{"title":"Leetcode 1498","permalink":"/blog/Leetcode 1498"}},"content":"Difficult problem I will come back to this question later. \\n```java\\nclass Solution {\\n    List<Integer> answer;\\n    // Find the rightmost insertion position. We use a fixed-length array and a changeable right boundary \\n    // to represent an arraylist of dynamic size.\\n    private int bisectRight(int[] A, int target, int right) {\\n        if (right == 0)\\n            return 0;\\n        int left = 0;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] <= target)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n    \\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\\n        int n = obstacles.length, lisLength = 0;\\n        \\n        // lis[i] records the lowest increasing sequence of length i + 1.\\n        int[] answer = new int[n], lis = new int[n];\\n\\n        for (int i = 0; i < n; ++i) {\\n            int height = obstacles[i];\\n            \\n            // Find the rightmost insertion position idx.\\n            int idx = bisectRight(lis, height, lisLength);\\n            if (idx == lisLength)\\n                lisLength++;\\n\\n            lis[idx] = height;\\n            answer[i] = idx + 1;\\n        }\\n        return answer;\\n    }\\n}\\n```"},{"id":"Leetcode 1498","metadata":{"permalink":"/blog/Leetcode 1498","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-05-Leet Code.md","source":"@site/blog/2023-05-05-Leet Code.md","title":"Leetcode 1498","description":"Todays question is bit harder than previous sliding window, because of findint the apparch , note we only need the min and max to determine if subsequnce between would be valid or not.","date":"2023-05-05T00:00:00.000Z","formattedDate":"May 5, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.93,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1498","title":"Leetcode 1498","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1964","permalink":"/blog/Leetcode 1964"},"nextItem":{"title":"Leetcode 1456","permalink":"/blog/Leetcode 1456"}},"content":"Todays question is bit harder than previous sliding window, because of findint the apparch , note we only need the min and max to determine if subsequnce between would be valid or not.\\n\\n```java\\nclass Solution {\\n    public int numSubseq(int[] nums, int target) {\\n        // still two pointer problem \\n        int n = nums.length;\\n        int MOD = 1000000007;\\n        Arrays.sort(nums);\\n\\n        // compute the value of 2 to the power of each value\\n        int[] power = new int[n];\\n        power[0] = 1;\\n        for(int i = 1; i < n; i ++){\\n            power[i] = (power[i - 1] * 2) % MOD;\\n        }\\n\\n        int res = 0;\\n        int left = 0, right = n - 1;\\n        while(left <= right){\\n            if(nums[left] + nums[right] <= target){\\n                // what this means is the min at left and max at right,\\n                // there are 2 ^ right - left subsequence that have nums[left] as the min and nums[right] as max, all theses subsequence is meeting our requirement.\\n                res += power[right - left];\\n                res %= MOD;\\n                left ++;\\n            }else{\\n                // max is too big, we shrink the window.\\n                right --;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"},{"id":"Leetcode 1456","metadata":{"permalink":"/blog/Leetcode 1456","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-04-Leet Code.md","source":"@site/blog/2023-05-04-Leet Code.md","title":"Leetcode 1456","description":"It just like question ask you longest substring without repating character, it is a sliding winodw problem. you keep track of the winodw and curr max and update the res.","date":"2023-05-04T00:00:00.000Z","formattedDate":"May 4, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.765,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1456","title":"Leetcode 1456","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1498","permalink":"/blog/Leetcode 1498"},"nextItem":{"title":"Leetcode 649","permalink":"/blog/Leetcode 649"}},"content":"It just like question ask you longest substring without repating character, it is a sliding winodw problem. you keep track of the winodw and curr max and update the res.\\n\\n```java\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        // sliding window \\n        int left = 0, right = 0;\\n        int res = 0;\\n        int curr = 0;\\n        while(right < s.length()){\\n            char c = s.charAt(right);\\n            if(c == \'a\' || c == \'e\' || c == \'i\' || c ==\'o\' || c == \'u\'){\\n                // vowel \\n                curr ++;\\n            }\\n            \\n            // shrink window\\n            while((right - left + 1) > k){\\n                // it is too big \\n                \\n                char shrink = s.charAt(left);\\n                if(shrink == \'a\' || shrink == \'e\' || shrink == \'i\' || shrink ==\'o\' || shrink == \'u\'){\\n                // vowel \\n                    curr --;\\n                }\\n                left ++;\\n            }\\n            if((right - left + 1) <= k){\\n                res = Math.max(res,curr);\\n            }\\n            right ++;\\n        }\\n        return res;\\n    }\\n}\\n```"},{"id":"Leetcode 649","metadata":{"permalink":"/blog/Leetcode 649","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-03-Leet Code.md","source":"@site/blog/2023-05-03-Leet Code.md","title":"Leetcode 649","description":"Natively we just follow the algorithm, since banning the next senate gives up the best advantage, we do that.","date":"2023-05-03T00:00:00.000Z","formattedDate":"May 3, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":2,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 649","title":"Leetcode 649","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1456","permalink":"/blog/Leetcode 1456"},"nextItem":{"title":"Leetcode 2215","permalink":"/blog/Leetcode 2215"}},"content":"Natively we just follow the algorithm, since banning the next senate gives up the best advantage, we do that.\\n\\n```java\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        // baning the new opposite party be the best \\n        StringBuilder senates = new StringBuilder(senate); // for easy deletion\\n        // Count of Each Type of Senator to check for Winner\\n        int rCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < senates.length(); i++) {\\n            if (senates.charAt(i) == \'R\') {\\n                rCount++;\\n            } else {\\n                dCount++;\\n            }\\n        }\\n\\n        int turn = 0;\\n        while(rCount > 0 && dCount > 0){\\n            // we have power still\\n            if(senates.charAt(turn) == \'R\'){\\n                // we going to ban next D\\n                boolean banning_from_before = ban(senates,\'D\',(turn + 1) % senates.length());\\n                if(banning_from_before){\\n                    turn --; //there is one opponent banned before this index, next to go is just next in turn\\n                }\\n                dCount --;\\n            }else{\\n                boolean banning_from_before = ban(senates,\'R\',(turn + 1) % senates.length());\\n                if(banning_from_before){\\n                    turn --; //there is one opponent banned before this index, next to go is just next in turn\\n                }\\n                rCount --;\\n            }\\n            turn = (turn + 1) % senates.length();\\n        }\\n        if(rCount == 0){\\n            return \\"Dire\\";\\n        }else{\\n            return \\"Radiant\\";\\n        }\\n    }\\n    private boolean ban(StringBuilder sb, Character party, int start){\\n        boolean flag = false;\\n        for(int i = start; i < start + sb.length(); i ++){\\n            int curr = i % sb.length();\\n            if(curr == 0) flag = true;\\n            if(sb.charAt(curr) == party){\\n                sb.deleteCharAt(curr);\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n    \\n}\\n```\\n\\n\\nA better solution for this is using some datasturcture to impvore our time complecity.\\nWhich structure serves first in first out? that is right a queue\\n\\n```java\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        // we still know the running curr senate for each party\\n        int rCount = 0, dCount = 0;\\n\\n        // Floating Ban Count\\n        int dFloatingBan = 0, rFloatingBan = 0;\\n        \\n        // Queue of senators\\n        Queue<Character> q = new LinkedList<>();\\n        for(char c : senate.toCharArray()){\\n            q.add(c);\\n            if(c == \'R\') rCount ++;\\n            else dCount ++;\\n        }\\n        while(rCount > 0 && dCount > 0){\\n            char curr = q.poll();\\n            if(curr == \'D\') {\\n                if(dFloatingBan > 0){\\n                    // we are banning this guy\\n                    dFloatingBan --;\\n                    dCount --;\\n                }else{\\n                    rFloatingBan ++; // banning next R\\n                    q.add(\'D\'); // adds back\\n                }\\n            }else{\\n                // same thing for ther other party\\n                if(rFloatingBan > 0){\\n                    rFloatingBan --;\\n                    rCount --;\\n                }else{\\n                    dFloatingBan ++;\\n                    q.add(\'R\');\\n                }\\n            }\\n        }\\n        return rCount == 0 ? \\"Dire\\" : \\"Radiant\\";\\n    }\\n}\\n```"},{"id":"Leetcode 2215","metadata":{"permalink":"/blog/Leetcode 2215","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-02-Leet Code.md","source":"@site/blog/2023-05-02-Leet Code.md","title":"Leetcode 2215","description":"Three easy question in a row, next might be hard. there is not much to talk about for this question.","date":"2023-05-02T00:00:00.000Z","formattedDate":"May 2, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.405,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 2215","title":"Leetcode 2215","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 649","permalink":"/blog/Leetcode 649"},"nextItem":{"title":"Leetcode 1822","permalink":"/blog/Leetcode 1822"}},"content":"Three easy question in a row, next might be hard. there is not much to talk about for this question.\\n```java\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> seen1 = new HashSet<>();\\n        Set<Integer> seen2 = new HashSet<>();\\n        for(int num : nums1){\\n            seen1.add(num);\\n        }\\n        Set<Integer> distinct2 = new HashSet<>();\\n        for(int num : nums2){\\n            seen2.add(num);\\n            if(!seen1.contains(num)){\\n                distinct2.add(num);\\n            }\\n        }\\n        Set<Integer> distinct1 = new HashSet<>();\\n        for(int num : nums1){\\n            if(!seen2.contains(num)){\\n                distinct1.add(num);\\n            }\\n        }\\n        return List.of(new ArrayList<>(distinct1),new ArrayList<>(distinct2));\\n    }\\n}\\n```"},{"id":"Leetcode 1822","metadata":{"permalink":"/blog/Leetcode 1822","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-05-01-Leet Code.md","source":"@site/blog/2023-05-01-Leet Code.md","title":"Leetcode 1822","description":"This is very easy question basically you count how many negative number.","date":"2023-05-01T00:00:00.000Z","formattedDate":"May 1, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.295,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1822","title":"Leetcode 1822","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 2215","permalink":"/blog/Leetcode 2215"},"nextItem":{"title":"Leetcode 1491","permalink":"/blog/Leetcode 1491"}},"content":"This is very easy question basically you count how many negative number.\\n\\n```java\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i ++){\\n            if(nums[i] == 0) return 0;\\n            if(nums[i] < 0){\\n                count ++;\\n            }\\n        }\\n        return count % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```"},{"id":"Leetcode 1491","metadata":{"permalink":"/blog/Leetcode 1491","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-30-Leet Code.md","source":"@site/blog/2023-04-30-Leet Code.md","title":"Leetcode 1491","description":"Since today\'s questions are too easy, we just put down the res for both weekly challange and daily challange.","date":"2023-04-30T00:00:00.000Z","formattedDate":"April 30, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.775,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1491","title":"Leetcode 1491","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1822","permalink":"/blog/Leetcode 1822"},"nextItem":{"title":"Leetcode 1579","permalink":"/blog/Leetcode 1579"}},"content":"Since today\'s questions are too easy, we just put down the res for both weekly challange and daily challange.\\n\\n## 1419\\n``` java\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int total = 0;\\n        for(int n : salary){\\n            min = Math.min(min,n);\\n            max = Math.max(max,n);\\n            total += n;\\n        }\\n        return (total - min - max) / (double)(salary.length - 2);\\n    }\\n}\\n```\\n\\n## 1065\\n```java\\n// the native apporach\\nclass Solution {\\n    public int[][] indexPairs(String text, String[] words) {\\n        ArrayList<int[]> res = new ArrayList<>();\\n        Arrays.sort(words,(a,b) ->{return a.length() - b.length();}); // insure the order.\\n        for(int i = 0; i < text.length(); i ++){\\n            for(String word : words){\\n                if(text.substring(i).startsWith(word)){\\n                    res.add(new int[]{i,i + word.length() - 1});\\n                }\\n            }\\n        }\\n        int[][] ans = new int[res.size()][2];\\n        for(int i = 0; i < res.size(); i ++){\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nBecause trie can detect a shorter word along the way, this avoid the sorting which can take extra time. this is a better solution.\\n\\n```java\\nclass Solution {\\n    public class TrieNode{\\n        boolean word;\\n        TrieNode[] children;\\n        public TrieNode(){\\n            word = false;\\n            children = new TrieNode[26]; //26 character\\n        }\\n    }\\n    public class MyTrie{\\n        TrieNode root;\\n        public MyTrie(){\\n            root = new TrieNode();\\n        }\\n        public void add(String word){\\n            TrieNode curr = root;\\n            for(char c : word.toCharArray()){\\n                if(curr.children[c - \'a\'] == null){\\n                    curr.children[c - \'a\'] = new TrieNode();\\n                }\\n                curr = curr.children[c - \'a\'];\\n            }\\n            curr.word = true;\\n        }\\n        public boolean serach(String word){\\n            TrieNode curr = root;\\n            for(char c : word.toCharArray()){\\n                if(curr.children[c - \'a\'] == null) return false;\\n                curr = curr.children[c - \'a\'];\\n            }\\n            return curr.word;\\n        }\\n        \\n    }\\n    public int[][] indexPairs(String text, String[] words) {\\n        MyTrie trie = new MyTrie();\\n        for(String word : words){\\n            trie.add(word);\\n        }\\n        List<int[]> res = new ArrayList<>();\\n        for(int i = 0; i < text.length(); i ++){\\n            TrieNode p = trie.root;\\n            for (int j = i; j < text.length(); j++) {\\n                if (p.children[text.charAt(j) - \'a\'] == null) {\\n                    break;\\n                }\\n                p = p.children[text.charAt(j) - \'a\'];\\n                if (p.word) {\\n                    res.add(new int[] { i, j });\\n                }\\n            }\\n        }\\n        int[][] ans = new int[res.size()][];\\n        ans = res.toArray(ans);\\n        return ans;\\n    }\\n}\\n```"},{"id":"Leetcode 1579","metadata":{"permalink":"/blog/Leetcode 1579","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-29-Leet Code.md","source":"@site/blog/2023-04-29-Leet Code.md","title":"Leetcode 1579","description":"Still union find, it is easy to identify, but there is little twist, initially I thought of sorting the edges, so we can union type 3 first, but this takes n log n time because sorting is bound by that, if we traversal twice the edges, still we only take just n time, so it would actually beat the way I implemented at begining. other than this, this question uses two union find data structure but everthing should be just the same.","date":"2023-04-29T00:00:00.000Z","formattedDate":"April 29, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.575,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1579","title":"Leetcode 1579","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1491","permalink":"/blog/Leetcode 1491"},"nextItem":{"title":"Leetcode 1697","permalink":"/blog/Leetcode 1697"}},"content":"Still union find, it is easy to identify, but there is little twist, initially I thought of sorting the edges, so we can union type 3 first, but this takes n log n time because sorting is bound by that, if we traversal twice the edges, still we only take just n time, so it would actually beat the way I implemented at begining. other than this, this question uses two union find data structure but everthing should be just the same. \\n\\n```java\\nclass Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        // still union find\\n        // we can remove edge if when we trying to connect the nodes are already connected\\n        UnionFind alice = new UnionFind(n);\\n        UnionFind bob = new UnionFind(n);\\n        int res = 0;\\n        // do union for type 3 first\\n        for(int[] edge : edges){\\n            if(edge[0] == 3){\\n                int a = edge[1];\\n                int b = edge[2];\\n                res += (alice.union(a,b) | bob.union(a,b));\\n            }\\n        }\\n\\n        for(int[] edge : edges){\\n            int type = edge[0];\\n            int a = edge[1];\\n            int b = edge[2];\\n            if(type == 1){\\n                res += alice.union(a,b);\\n            }else if(type == 2){\\n                res += bob.union(a,b);\\n            }\\n        }\\n\\n        if(alice.isValid() && bob.isValid()){\\n            return edges.length - res;\\n        }else{\\n            return -1;\\n        }\\n    }\\n    public class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        int n;\\n        public UnionFind(int n){\\n            parent = new int[n + 1];\\n            size = new int[n + 1];\\n            for(int i = 0; i <= n; i ++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n            this.n = n;\\n        }\\n        public int find(int a){\\n            if(parent[a] == a) return a;\\n            return parent[a] = find(parent[a]);\\n        }\\n        public int union(int a, int b){\\n            int pa = find(a);\\n            int pb = find(b);\\n            if(pa == pb) return 0;\\n            if(size[pa] > size[pb]){\\n                // join b into a \\n                parent[pb] = a;\\n                size[pa] += size[pb];\\n            }else{\\n                parent[pa] = b;\\n                size[pb] += size[pa];\\n            }\\n            n --;\\n            return 1;\\n        }\\n        public boolean isValid(){\\n            return n == 1;\\n        }\\n    }\\n}\\n```"},{"id":"Leetcode 1697","metadata":{"permalink":"/blog/Leetcode 1697","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-28-Leet Code.md","source":"@site/blog/2023-04-28-Leet Code.md","title":"Leetcode 1697","description":"Another same union find question , you can figure out it is a union find problem by the hint that determine a and b connected and a minimal spanning tree kind of a deal.","date":"2023-04-28T00:00:00.000Z","formattedDate":"April 28, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.43,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1697","title":"Leetcode 1697","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1579","permalink":"/blog/Leetcode 1579"},"nextItem":{"title":"Leetcode 839","permalink":"/blog/Leetcode 839"}},"content":"Another same union find question , you can figure out it is a union find problem by the hint that determine a and b connected and a minimal spanning tree kind of a deal.\\n\\n```java\\nclass Solution {\\n    int[] parent;\\n    int[] size;\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int queriesCount = queries.length;\\n        boolean[] res = new boolean[queriesCount];\\n        // init \\n        parent = new int[n];\\n        size = new int[n];\\n        for(int i = 0; i < n; i ++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n        // Store original indices with all queries.\\n        int[][] queriesWithIndex = new int[queriesCount][4];\\n        for (int i = 0; i < queriesCount; ++i) {\\n            queriesWithIndex[i][0] = queries[i][0];\\n            queriesWithIndex[i][1] = queries[i][1];\\n            queriesWithIndex[i][2] = queries[i][2];\\n            queriesWithIndex[i][3] = i;\\n        }\\n        Arrays.sort(edgeList,(a,b) ->{return a[2] - b[2];});\\n        Arrays.sort(queriesWithIndex,(a,b) ->{return a[2] - b[2];});\\n        int edgesIndex = 0;\\n        for(int i = 0; i < queriesCount; i ++){\\n            int p = queriesWithIndex[i][0];\\n            int q = queriesWithIndex[i][1];\\n            int limit = queriesWithIndex[i][2];\\n            int originalIndex = queriesWithIndex[i][3];\\n            // because we have the edges sorted\\n            // while our paths are smaller than limit, we want to attache all the edges thta is less than limit\\n            // if this made p q in a same union aka connected, we return true\\n            while(edgesIndex < edgeList.length && edgeList[edgesIndex][2] < limit){\\n                int node1 = edgeList[edgesIndex][0];\\n                int node2 = edgeList[edgesIndex][1];\\n                union(node1,node2);\\n                edgesIndex += 1;\\n            }\\n            res[originalIndex] = find(p) == find(q);\\n        }\\n        return res;\\n        \\n    }\\n    private int find(int a){\\n        if(parent[a] == a) return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    private int union(int a, int b){\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa == pb) return 0;\\n        if(size[pa] > pb){\\n            parent[pb] = a;\\n            size[pa] += size[pb];\\n        }else{\\n            parent[pa] = b;\\n            size[pb] += size[pa];\\n        }\\n        return 1;\\n    }\\n}\\n```"},{"id":"Leetcode 839","metadata":{"permalink":"/blog/Leetcode 839","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-27-Leet Code.md","source":"@site/blog/2023-04-27-Leet Code.md","title":"Leetcode 839","description":"This question is marked hard, but in realality this is not a difficult question. Simple union find problem, you find all the samilar strs and union them , starts with n groups after union all possible strs, what you have left is group standing.","date":"2023-04-27T00:00:00.000Z","formattedDate":"April 27, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.125,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 839","title":"Leetcode 839","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1697","permalink":"/blog/Leetcode 1697"},"nextItem":{"title":"Leetcode 319","permalink":"/blog/Leetcode 319"}},"content":"This question is marked hard, but in realality this is not a difficult question. Simple union find problem, you find all the samilar strs and union them , starts with n groups after union all possible strs, what you have left is group standing. \\n\\n```java\\nclass Solution {\\n    // union find \\n    int[] parent;\\n    int[] size;\\n    public int numSimilarGroups(String[] strs) {\\n        int n = strs.length;\\n        parent = new int[n];\\n        size = new int[n];\\n        for(int i = 0; i < n; i ++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n        int count = n;\\n        for(int i = 0; i < n; i ++){\\n            for(int j = i + 1; j < n; j ++){\\n                String a = strs[i];\\n                String b = strs[j];\\n                if(similar(a,b)){\\n                    count -= union(i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private int find(int a){\\n        if(parent[a] == a) return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    private int union(int a, int b){\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa == pb) return 0;\\n        if(size[pa] > size[pb]){\\n            // join b to a \\n            parent[pb] = a;\\n            size[pa] += size[pb];\\n        }else{\\n            parent[pa] = b;\\n            size[pb] += size[pa];\\n        }\\n        return 1;\\n    }\\n    private boolean similar(String a, String b){\\n        int diff = 0;\\n        for(int i = 0; i < a.length(); i ++){\\n            if(a.charAt(i) != b.charAt(i)){\\n                diff ++;\\n            }\\n        }\\n        return diff == 2 || diff == 0;\\n    }\\n}\\n```"},{"id":"Leetcode 319","metadata":{"permalink":"/blog/Leetcode 319","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-26-Leet Code.md","source":"@site/blog/2023-04-26-Leet Code.md","title":"Leetcode 319","description":"This is a harder question for me, write on paper and find the parttern.","date":"2023-04-26T00:00:00.000Z","formattedDate":"April 26, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.47,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 319","title":"Leetcode 319","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 839","permalink":"/blog/Leetcode 839"},"nextItem":{"title":"Leetcode 258","permalink":"/blog/Leetcode 258"}},"content":"This is a harder question for me, write on paper and find the parttern. \\n```java\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        // n == 0 all bulbs are off\\n        // n == 1 all bulbs with factor of 1 \\n        // n == 2 all bulbs with factor 2 (2,4,6,8,10)...\\n        // n == 3 all bulbs with factor 3 (3,6,9).....\\n        // ......\\n        // so we are finding number from 1 to n are perfect square\\n        // essencially we are trying to find the sqrt of the n \\n        return (int) Math.sqrt(n);\\n    }\\n}\\n```"},{"id":"Leetcode 258","metadata":{"permalink":"/blog/Leetcode 258","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-25-Leet Code.md","source":"@site/blog/2023-04-25-Leet Code.md","title":"Leetcode 258","description":"Simple reccurssion, you have a base case where you have just 1 digit, simply return it, you have recussive case, you add all the digit and return addDigits adds all these digit recurssively","date":"2023-04-25T00:00:00.000Z","formattedDate":"April 25, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.355,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 258","title":"Leetcode 258","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 319","permalink":"/blog/Leetcode 319"},"nextItem":{"title":"Leetcode 2336","permalink":"/blog/Leetcode 2336"}},"content":"Simple reccurssion, you have a base case where you have just 1 digit, simply return it, you have recussive case, you add all the digit and return addDigits adds all these digit recurssively\\n\\n\\n```java\\nclass Solution {\\n    public int addDigits(int num) {\\n        // base case\\n        if(num < 10) return num;\\n        int res = 0;\\n        while(num != 0){\\n            res += num % 10;\\n            num /= 10;\\n        }\\n        return addDigits(res);\\n    }\\n}\\n```"},{"id":"Leetcode 2336","metadata":{"permalink":"/blog/Leetcode 2336","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-24-Leet Code.md","source":"@site/blog/2023-04-24-Leet Code.md","title":"Leetcode 2336","description":"Consider we have a full infinite set at first","date":"2023-04-24T00:00:00.000Z","formattedDate":"April 24, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.745,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 2336","title":"Leetcode 2336","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 258","permalink":"/blog/Leetcode 258"},"nextItem":{"title":"Leetcode 1046","permalink":"/blog/Leetcode 1046"}},"content":"Consider we have a full infinite set at first\\nUse a running curr to keep track of smallest number and priority queue to keep track if we have scarlet numbers before running smallest\\n```java\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    int curr;\\n    public SmallestInfiniteSet() {\\n        // set curr smallest to 1\\n        curr = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(!pq.isEmpty())return pq.poll();\\n        // if we have nothing in pq, curr smallest is what we poll out, and sus next number would be curr + 1\\n        curr ++;\\n        return curr - 1;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(num < curr & !pq.contains(num)){\\n            // number is small and we dont have it in our pq \\n            // add back\\n            pq.add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```"},{"id":"Leetcode 1046","metadata":{"permalink":"/blog/Leetcode 1046","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-23-Leet Code.md","source":"@site/blog/2023-04-23-Leet Code.md","title":"Leetcode 1046","description":"Very straightforward question, just mimc the instruction using priority queue.","date":"2023-04-23T00:00:00.000Z","formattedDate":"April 23, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.505,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1046","title":"Leetcode 1046","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 2336","permalink":"/blog/Leetcode 2336"},"nextItem":{"title":"Leetcode 1416","permalink":"/blog/Leetcode 1416"}},"content":"Very straightforward question, just mimc the instruction using priority queue.\\n\\n```java\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        // very straight forward, we use priority queue to ensure we polling the largest 2 stones\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{return b - a;});\\n        for(int stone : stones){\\n            pq.add(stone);\\n        }\\n        // while we have 2 or more stones\\n        while(pq.size() > 1){\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a != b){\\n                int remain = Math.abs(a - b);\\n                pq.add(remain);\\n            }\\n        }\\n        // return nothing if we got no stone or last stone standing.\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```"},{"id":"Leetcode 1416","metadata":{"permalink":"/blog/Leetcode 1416","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-22-Leet Code.md","source":"@site/blog/2023-04-22-Leet Code.md","title":"Leetcode 1416","description":"All the dp problem is kinda similar, this is marked at hard, but in reality it is backtrack question possible sub array partition with little modification.","date":"2023-04-22T00:00:00.000Z","formattedDate":"April 22, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.87,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1416","title":"Leetcode 1416","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 1046","permalink":"/blog/Leetcode 1046"},"nextItem":{"title":"Leetcode 727","permalink":"/blog/Leetcode 727"}},"content":"All the dp problem is kinda similar, this is marked at hard, but in reality it is backtrack question possible sub array partition with little modification. \\n```java\\nclass Solution {\\n    int[] memo;\\n    int MOD = 1000000007;\\n    public int numberOfArrays(String s, int k) {\\n        memo = new int[s.length() + 1];\\n        Arrays.fill(memo,-1);\\n        return dp(s,k,0);\\n    }\\n    private int dp(String s, int k, int curr){\\n        // base case \\n        if(curr == s.length()) return 1; // we have no more possible number to play with\\n        if(s.charAt(curr) == \'0\') return 0; // leading zero\\n        // solved case\\n        if(memo[curr] != -1) return memo[curr];\\n        // start res with 0\\n        int res = 0;\\n        for(int i = curr; i < s.length(); i ++){\\n            // try pairtition at every possible point\\n            String num = s.substring(curr,i + 1);\\n            // if num > k then we know we cant have this number\\n            if (Long.parseLong(num) > k)\\n                break;\\n            // add to res if we made to the end (+ 1) res\\n            res = (res + dp(s,k,i + 1)) % MOD;\\n\\n        }\\n        return memo[curr] = res;\\n    }\\n}\\n```"},{"id":"Leetcode 727","metadata":{"permalink":"/blog/Leetcode 727","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-21-Leet Code Weekly Challenge.md","source":"@site/blog/2023-04-21-Leet Code Weekly Challenge.md","title":"Leetcode 727","description":"This question interesting because our dp is not finding the min of the length but it is finding the ending index of given starting point p1. This is a very new DP problem that I have first encountered.","date":"2023-04-21T00:00:00.000Z","formattedDate":"April 21, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"weeklychallenge","permalink":"/blog/tags/weeklychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":1.2,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 727","title":"Leetcode 727","authors":["junhechen"],"tags":["leetcode","weeklychallenge","notes"]},"prevItem":{"title":"Leetcode 1416","permalink":"/blog/Leetcode 1416"},"nextItem":{"title":"Leetcode 1312","permalink":"/blog/Leetcode 1312"}},"content":"This question interesting because our dp is not finding the min of the length but it is finding the ending index of given starting point p1. This is a very new DP problem that I have first encountered. \\n\\n```java\\nclass Solution {\\n    Integer[][] memo;\\n    int min = Integer.MAX_VALUE;\\n    int start = -1;\\n    public String minWindow(String s1, String s2) {\\n        memo = new Integer[s1.length()][s2.length() + 1];\\n        dp(s1,s2,0,0);\\n        return start == -1 ? \\"\\" : s1.substring(start,start + min);\\n    }\\n    private int dp(String s1, String s2, int p1, int p2){ \\n        // we use dp method to find the ending index at given index of s1 \\n\\n        if(p2 == s2.length()) return p1; // we have all the character from p2\\n        if(p1 == s1.length()) return Integer.MAX_VALUE; // we are not able to match \\n        // solved case\\n        if(memo[p1][p2] != null) return memo[p1][p2];\\n        // solve the case \\n        // starts with skip the character\\n        int res = dp(s1,s2,p1 + 1, p2);\\n        if(s1.charAt(p1) == s2.charAt(p2)){\\n            // we have a match \\n            res = Math.min(res,dp(s1,s2,p1 + 1, p2 + 1));\\n        }\\n        if(p2 == 0 && res < Integer.MAX_VALUE){\\n            // this is a valid starting point \\n            // note since we called skip first, that means we are always replacing the substring as we moving forward \\n            // so res - p1 <= min is important here to locate the correct starting point\\n            if(res - p1 <= min){\\n                min = res - p1;\\n                start = p1;\\n            }\\n        }\\n        return memo[p1][p2] = res;\\n    }\\n    ```\\n}"},{"id":"Leetcode 1312","metadata":{"permalink":"/blog/Leetcode 1312","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-21-Leet Code/index.md","source":"@site/blog/2023-04-21-Leet Code/index.md","title":"Leetcode 1312","description":"This week we are been doing DP problems and this is one of them, it is quite easy to implement, but little tricky to find the entry point.","date":"2023-04-21T00:00:00.000Z","formattedDate":"April 21, 2023","tags":[{"label":"leetcode","permalink":"/blog/tags/leetcode"},{"label":"dailychallenge","permalink":"/blog/tags/dailychallenge"},{"label":"notes","permalink":"/blog/tags/notes"}],"readingTime":0.915,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"Leetcode 1312","title":"Leetcode 1312","authors":["junhechen"],"tags":["leetcode","dailychallenge","notes"]},"prevItem":{"title":"Leetcode 727","permalink":"/blog/Leetcode 727"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"This week we are been doing DP problems and this is one of them, it is quite easy to implement, but little tricky to find the entry point.\\n\\n```java\\nclass Solution {\\n    Integer[][] memo;\\n    public int minInsertions(String s) {\\n        // we can think this as in a different prespective \\n        // what is longest we have to insert to make this a palindrome?\\n        // that is correct we can insert s in reverse to complish that, \\n        // if we take out the character we already have that means everthing else would then become palindrome \\n        memo = new Integer[s.length()][s.length()];\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        return s.length() - lcs(s,sb.reverse().toString(),0,0);\\n    }\\n    private int lcs(String s1, String s2, int p1, int p2){\\n        // base case \\n        // case if we used one of the string up \\n        if(p1 == s1.length()) return 0;  \\n        if(p2 == s2.length()) return 0; \\n        // solved case\\n        if(memo[p1][p2] != null) return memo[p1][p2];\\n        // solve the case \\n        \\n        if(s1.charAt(p1) == s2.charAt(p2)){\\n            // if we have a match \\n            return memo[p1][p2] =  1 + lcs(s1,s2,p1 + 1,p2 + 1);\\n        }\\n        return memo[p1][p2] = Math.max(lcs(s1,s2,p1 + 1,p2),lcs(s1,s2,p1,p2 + 1));\\n    }\\n}\\n```"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/Junhe-Chen-9/junhe-s-documentations/blob/main/blog/2023-04-20-welcome/index.md","source":"@site/blog/2023-04-20-welcome/index.md","title":"Welcome","description":"\ud83d\udc4b Hi!","date":"2023-04-20T00:00:00.000Z","formattedDate":"April 20, 2023","tags":[{"label":"helloworld","permalink":"/blog/tags/helloworld"}],"readingTime":0.53,"hasTruncateMarker":false,"authors":[{"name":"Junhe Chen","title":"Software Developer","url":"https://bio.junhechen.com","imageURL":"https://bio.junhechen.com/assets/IMG_0001.jpeg","key":"junhechen"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["junhechen"],"tags":["helloworld"]},"prevItem":{"title":"Leetcode 1312","permalink":"/blog/Leetcode 1312"}},"content":"## \ud83d\udc4b Hi! ##\\n\\nI\'m Junhe Chen [(JC)](https://bio.junhechen.com), a full stack software engineer. Proven talent for aligning project objectives with established and emerging computer science paradigms to achieve maximum operational impacts with minimum resource expenditures. Growth-focused leader with expertise spanning technology solutions, project management, business operations optimization, application development, team leadership, and client relationship management. Exceptional student with keen interpersonal, communications, and application development expertise.\\n\\n## Introduction ##\\nThis blog is mainly used to :\\n- take notes for my leetcode challanges.\\n- update learning notes from other readings.\\n\\n\\n## Social Card ##\\n![Social Card](./social-card.png)\\n\\n***If you found information here useful, feel free to review them.***"}]}')}}]);